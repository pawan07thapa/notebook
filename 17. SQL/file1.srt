1
00:00:00,000 --> 00:00:04,000
Hi, my name is Mosh Hamedani, and I'm 

2
00:00:04,000 --> 00:00:08,000
super excited to be your instructor. In this three hour course, you're going to learn everything 

3
00:00:08,000 --> 00:00:12,000
you need to get started with SQL or SQUEL. First I'm going to

4
00:00:12,000 --> 00:00:16,000
give you a three minute introduction to SQL, then we're going to install the necessary 

5
00:00:16,000 --> 00:00:20,000
tools and write our first SQL query. This course

6
00:00:20,000 --> 00:00:24,000
is ideal for anyone who wants to learn SQL from scratch, but also 

7
00:00:24,000 --> 00:00:28,000
anyone with some basic knowledge who wants to fill in the missing gaps. By the end 

8
00:00:28,000 --> 00:00:32,000
of this course, you'll be able to retrieve insert, update, and 

9
00:00:32,000 --> 00:00:36,000
delete data in databases. We'll talk about tables, relationships, 

10
00:00:36,000 --> 00:00:40,000
different types of joints, sub-queries regular expressions and 

11
00:00:40,000 --> 00:00:44,000
much, much, more. These are the essential concepts every software developer 

12
00:00:44,000 --> 00:00:48,000
or data scientist must know. This SQL course is packed with tons 

13
00:00:48,000 --> 00:00:52,000
of exercises that help you both learn and remember the SQL syntax.

14
00:00:52,000 --> 00:00:56,000
Also, there is a table of content below this video so you can quickly jump

15
00:00:56,000 --> 00:01:00,000
to specific tutorials, now let's jump in and get started. 

16
00:01:00,000 --> 00:01:04,000


17
00:01:04,000 --> 00:01:08,000
Let's start the course with a quick overview of databases, what they are and 

18
00:01:08,000 --> 00:01:12,000
how we use them. A database is a collection of data stored 

19
00:01:12,000 --> 00:01:16,000
in a format that can be easily accessed. In order to manage our

20
00:01:16,000 --> 00:01:20,000
databases, we use a software application called database management system, 

21
00:01:20,000 --> 00:01:24,000
or, DBMS. We connect to a DBMS and give it 

22
00:01:24,000 --> 00:01:28,000
instructions for querying or modifying data. The DMBS will

23
00:01:28,000 --> 00:01:32,000
execute our instructions and send results back. Now we have 

24
00:01:32,000 --> 00:01:36,000
several database management systems out there, and these are classified into

25
00:01:36,000 --> 00:01:40,000
two categories, relational and non relational, also 

26
00:01:40,000 --> 00:01:44,000
called NoSQL. In relational databases, we store data

27
00:01:44,000 --> 00:01:48,000
in tables that are linked to each other using relationships. That's

28
00:01:48,000 --> 00:01:52,000
why we call these databases relational databases, each table 

29
00:01:52,000 --> 00:01:56,000
stores data about a specific type of object, like customer

30
00:01:56,000 --> 00:02:00,000
product, order and so on. SQL or SQUEL is

31
00:02:00,000 --> 00:02:04,000
the language that we use to work with these relational database

32
00:02:04,000 --> 00:02:08,000
management systems. It looks like this. We use SQL to query

33
00:02:08,000 --> 00:02:12,000
or modify our data. In this course you're going to learn everything there is to know about this powerful 

34
00:02:12,000 --> 00:02:16,000
language. Now, there are many different relational database management systems, 

35
00:02:16,000 --> 00:02:20,000
out there, some of the most popular ones are MySQL,

36
00:02:20,000 --> 00:02:24,000
SQL Server my Microsoft, and Oracle. But of course, there are plenty 

37
00:02:24,000 --> 00:02:28,000
more. Each database management system has a different flavor of SQL. 

38
00:02:28,000 --> 00:02:32,000
But all these implementations are very similar and are based on

39
00:02:32,000 --> 00:02:36,000
the standard SQL specification. So most of the SQL 

40
00:02:36,000 --> 00:02:40,000
code that you will learn in this course will work with any database management system. 

41
00:02:40,000 --> 00:02:44,000
In this course, we'll be using MySQL, which is the most popular 

42
00:02:44,000 --> 00:02:48,000
open source database in the world. Okay, now back to this diagram, 

43
00:02:48,000 --> 00:02:52,000
what about non relational databases? In non relational databases, 

44
00:02:52,000 --> 00:02:56,000
we don't have tables or relationships, these databases are

45
00:02:56,000 --> 00:03:00,000
different from relational databases, but that's a topic for an entirely different course. 

46
00:03:00,000 --> 00:03:04,000
What you need to know is non relational database systems 

47
00:03:04,000 --> 00:03:08,000
don't understand SQL. They have their own query language. 

48
00:03:08,000 --> 00:03:12,000
So, we use SQL to work with relational database management 

49
00:03:12,000 --> 00:03:16,000
systems. Now, before we jump in and install MySql, let me clarify 

50
00:03:16,000 --> 00:03:20,000
something quickly, as you talk to different people, you will hear two different pronunciations 

51
00:03:20,000 --> 00:03:24,000
of SQL. SQUEL, or SQL. 

52
00:03:24,000 --> 00:03:28,000
What is the correct way? Well, it depends on who you ask, and

53
00:03:28,000 --> 00:03:32,000
of course everybody thinks their way of pronouncing this word is the right way. But here's a 

54
00:03:32,000 --> 00:03:36,000
history about this language. SQL was originally developed at IBM

55
00:03:36,000 --> 00:03:40,000
in the 70s and back then it was initially called SQUEL

56
00:03:40,000 --> 00:03:44,000
short for structured English query language. But they changed

57
00:03:44,000 --> 00:03:48,000
the acronym to SQL, because SQUEL was the trademark of an airplane 

58
00:03:48,000 --> 00:03:52,000
company. So to this day, there has been an argument about what is the right

59
00:03:52,000 --> 00:03:56,000
generally speaking, people in non-English speaking 

60
00:03:56,000 --> 00:04:00,000
countries call it SQL. I'm used to calling it SQUEL

61
00:04:00,000 --> 00:04:04,000
because it's shorter and sweeter than SQL. But if you prefer to

62
00:04:04,000 --> 00:04:08,000
call it SQL, that's totally fine with me, I'm not going to get mad at you. So that's

63
00:04:08,000 --> 00:04:12,000
the history behind this language. But what about MySQL as a 

64
00:04:12,000 --> 00:04:16,000
software product? Developers of this product prefer to call it MySQL rather

65
00:04:16,000 --> 00:04:20,000
than mySQL. But they don't mind if they call it MySQL. 

66
00:04:20,000 --> 00:04:24,000
In this course, I'll be teaching you SQL with MySQL. 

67
00:04:24,000 --> 00:04:28,000
Hey guys, Mosh here. I just wanted to let you know that 

68
00:04:28,000 --> 00:04:32,000
you really don't have to memorize anything in this course, because I've created a 

69
00:04:32,000 --> 00:04:36,000
complete cheat sheet with summary notes for you. You can find it below this video 

70
00:04:36,000 --> 00:04:40,000
in the description box. So I have done my best to create

71
00:04:40,000 --> 00:04:44,000
the best possible, most comprehensive SQL course for you, and

72
00:04:44,000 --> 00:04:48,000
I would really appreciate it if you would support my hard work by liking and sharing this 

73
00:04:48,000 --> 00:04:52,000
video. Thank you so much, now, let's continue. 

74
00:04:52,000 --> 00:04:56,000
In this tutorial, 

75
00:04:56,000 --> 00:05:00,000
I'm going to show you how to install MySQL on your computer. Now

76
00:05:00,000 --> 00:05:04,000
I'm using a Mac, so first I will show you how to install MySQL on a Mac 

77
00:05:04,000 --> 00:05:08,000
computer, and then I will show you how to install it on Windows. So if you're a Windows user, 

78
00:05:08,000 --> 00:05:12,000
feel free to skip this tutorial. Now, open up your browser and

79
00:05:12,000 --> 00:05:16,000
head over to MySQL.com. Then, go to the

80
00:05:16,000 --> 00:05:20,000
downloads page, and scroll down to the bottom.

81
00:05:20,000 --> 00:05:24,000
Here you should see MySQL community edition, this is absolutely 

82
00:05:24,000 --> 00:05:28,000
free, and we're going to use that throughout this course. So let's go ahead 

83
00:05:28,000 --> 00:05:32,000
and look at that, now on this page, click on MySQL, 

84
00:05:32,000 --> 00:05:36,000
community server, and then on this page, 

85
00:05:36,000 --> 00:05:40,000
you should see available releases for Mac OS. 

86
00:05:40,000 --> 00:05:44,000
So, in this list, download the first item which is a dmg archive. 

87
00:05:44,000 --> 00:05:48,000
Alright, now, on the next page, click

88
00:05:48,000 --> 00:05:52,000
on no thanks, just start my download. Okay, as you can

89
00:05:52,000 --> 00:05:56,000
see, we are getting a dmg file, which is basically a setup wizard. 

90
00:05:56,000 --> 00:06:00,000
Alright, now the DMG is downloaded, so let's open it, 

91
00:06:00,000 --> 00:06:04,000
and then double click on this package, this

92
00:06:04,000 --> 00:06:08,000
will launch an installation wizard which is pretty easy to use, so simply 

93
00:06:08,000 --> 00:06:12,000
click on continue and again, and again, 

94
00:06:12,000 --> 00:06:16,000
agree with the license agreement, and 

95
00:06:16,000 --> 00:06:20,000
install MySQL, it's going to ask for your password, this is the password 

96
00:06:20,000 --> 00:06:24,000
that you used to log into your computer, so let's put that here, 

97
00:06:24,000 --> 00:06:28,000
alright, now here we need to set a password to the root

98
00:06:28,000 --> 00:06:32,000
for the admin user. So click next, and 

99
00:06:32,000 --> 00:06:36,000
in this box, type a complex password, 

100
00:06:36,000 --> 00:06:40,000
alright, now, let's finish the installation, 

101
00:06:40,000 --> 00:06:44,000
and enter your computer's password one more time, 

102
00:06:44,000 --> 00:06:48,000
and we are done! 

103
00:06:48,000 --> 00:06:52,000
That was super easy and sweet. 

104
00:06:52,000 --> 00:06:56,000
Alright, we installed MySQL community server, now we 

105
00:06:56,000 --> 00:07:00,000
need the graphical tool to connect with this server and manage our databases. 

106
00:07:00,000 --> 00:07:04,000
So, back to the downloads page, one more time, 

107
00:07:04,000 --> 00:07:08,000
scroll to the bottom, and go to MySQL 

108
00:07:08,000 --> 00:07:12,000
community addition, and on this page, somewhere 

109
00:07:12,000 --> 00:07:16,000
you should see MySQL workbench. This is a graphical tool that we use to

110
00:07:16,000 --> 00:07:20,000
connect to our database server. So let's go ahead and 

111
00:07:20,000 --> 00:07:24,000
download this as well. Now once again on this

112
00:07:24,000 --> 00:07:28,000
page, we need to download a dmg archive, so, 

113
00:07:28,000 --> 00:07:32,000
download, and, again we have 

114
00:07:32,000 --> 00:07:36,000
to say no we don't want to login or sign up, so let's go ahead and download 

115
00:07:36,000 --> 00:07:40,000
the dmg, and then 

116
00:07:40,000 --> 00:07:44,000
open it, alright, you're going to see something like this, so 

117
00:07:44,000 --> 00:07:48,000
drag this MySQL workbench and drop it onto the applications folder. 

118
00:07:48,000 --> 00:07:52,000
So, let's go ahead with that, now it's going to copy 

119
00:07:52,000 --> 00:07:56,000
this into the applications folder, beautiful, 

120
00:07:56,000 --> 00:08:00,000
so we're done with the installation, that was super easy, now press

121
00:08:00,000 --> 00:08:04,000
command and space, and search for MySQL, 

122
00:08:04,000 --> 00:08:08,000
work bench, there you go, let's open it, now the 

123
00:08:08,000 --> 00:08:12,000
first time we get this message, because this is an application we downloaded from the internet. 

124
00:08:12,000 --> 00:08:16,000
So, we need to tell Mac that we trust this, let's go ahead with that, 

125
00:08:16,000 --> 00:08:20,000
so this is MySQL workbench, now by default 

126
00:08:20,000 --> 00:08:24,000
you see a connection here, if you don't see that, you need to create it.

127
00:08:24,000 --> 00:08:28,000
Let me show you how to do that. So for this demo I'm going to right click this and

128
00:08:28,000 --> 00:08:32,000
delete this connection, alright, 

129
00:08:32,000 --> 00:08:36,000
now let's create a connection from scratch. So click on this plus icon, 

130
00:08:36,000 --> 00:08:40,000
on this page, give this connection a name, let's 

131
00:08:40,000 --> 00:08:44,000
say local instance, now the connection method 

132
00:08:44,000 --> 00:08:48,000
we're going to use is tcip, which is set by default, the 

133
00:08:48,000 --> 00:08:52,000
host name is 127.0.0.1, which 

134
00:08:52,000 --> 00:08:56,000
is the address of the local machine, and the port is 33

135
00:08:56,000 --> 00:09:00,000
06, this is the default port for MySQL server, that is

136
00:09:00,000 --> 00:09:04,000
the user name of the admin, now we need to enter the password. This is

137
00:09:04,000 --> 00:09:08,000
the password that we set during the installation. So, click on 

138
00:09:08,000 --> 00:09:12,000
store in keychain, and in this box, type the 

139
00:09:12,000 --> 00:09:16,000
password for the MySQL server. Alright 

140
00:09:16,000 --> 00:09:20,000
and finally, let's test the 

141
00:09:20,000 --> 00:09:24,000
connection, okay, we successfully connected to MySQL

142
00:09:24,000 --> 00:09:28,000
server on the local machine, beautiful, let's click okay, 

143
00:09:28,000 --> 00:09:32,000
and here we have a connection on the homepage of MySQL

144
00:09:32,000 --> 00:09:36,000
workbench, every time we open MySQL workbench, we use this

145
00:09:36,000 --> 00:09:40,000
connection to connect to our local server. Alright, we're done

146
00:09:40,000 --> 00:09:44,000
with the installation of MySQL on a Mac, next I will talk about

147
00:09:44,000 --> 00:09:48,000
MySQL on a Windows computer, so feel free to skip that tutorial.

148
00:09:48,000 --> 00:09:52,000


149
00:09:52,000 --> 00:09:56,000
In this tutorial, I'm going to show you how to install

150
00:09:56,000 --> 00:10:00,000
MySQL on Windows. So open up your browser and head over to

151
00:10:00,000 --> 00:10:04,000
MySQL.com, then, go to the downloads page

152
00:10:04,000 --> 00:10:08,000
now here, scroll down to the bottom, 

153
00:10:08,000 --> 00:10:12,000
we're going to use MySQL community edition which is absolutely 

154
00:10:12,000 --> 00:10:16,000
free. So, let's go with this, now, 

155
00:10:16,000 --> 00:10:20,000
select MySQL community server, 

156
00:10:20,000 --> 00:10:24,000
and then scroll down so here you should see

157
00:10:24,000 --> 00:10:28,000
something like this, MySQL installer for Windows. This is the 

158
00:10:28,000 --> 00:10:32,000
recommended method for installing MySQL on Windows. So, 

159
00:10:32,000 --> 00:10:36,000
click on this, alright, on the next page, scroll down, 

160
00:10:36,000 --> 00:10:40,000
and 

161
00:10:40,000 --> 00:10:44,000
download the first installer here. On the next page 

162
00:10:44,000 --> 00:10:48,000
scroll downs nd click on no thanks just start my 

163
00:10:48,000 --> 00:10:52,000
download. Otherwise you have to create an account and log, which is unnecessary for

164
00:10:52,000 --> 00:10:56,000
knowing this course, so, let's go with this, 

165
00:10:56,000 --> 00:11:00,000
and save this file to our computer, and then 

166
00:11:00,000 --> 00:11:04,000
run it. 

167
00:11:04,000 --> 00:11:08,000
Alright, we're going to use this setup wizard to install MySQL, 

168
00:11:08,000 --> 00:11:12,000
on our computer.  This is very easy, all you have to do is click next, 

169
00:11:12,000 --> 00:11:16,000
but there are a couple places where you need to enter a password, let me show you.

170
00:11:16,000 --> 00:11:20,000
So, on the first page, for the setup type we're going to use the 

171
00:11:20,000 --> 00:11:24,000
developer default setup. Go to the next page.

172
00:11:24,000 --> 00:11:28,000
Now here we're getting a little warning, because this installation wizard wants to

173
00:11:28,000 --> 00:11:32,000
install the connector for python 3.7, but I

174
00:11:32,000 --> 00:11:36,000
don't have Python on this machine, so that's why I'm getting this warning, now on your 

175
00:11:36,000 --> 00:11:40,000
machine, you might or you might not get this error, just click 

176
00:11:40,000 --> 00:11:44,000
next, and one more time, so here are

177
00:11:44,000 --> 00:11:48,000
the products that I want to get installed the first one is MySQL server, 

178
00:11:48,000 --> 00:11:52,000
the second one is MySQL workbench, this is the graphical

179
00:11:52,000 --> 00:11:56,000
tool that we use to connect to our database server, and manage our database. 

180
00:11:56,000 --> 00:12:00,000
You're going to see that soon. So click on execute, 

181
00:12:00,000 --> 00:12:04,000
now this is going to take about 5-10 minutes, so, 

182
00:12:04,000 --> 00:12:08,000
I'm going to pause the recording. 

183
00:12:08,000 --> 00:12:12,000
Alright, all the products are installed, beautiful, let's go to the next page, 

184
00:12:12,000 --> 00:12:16,000
and again, here our the group replication 

185
00:12:16,000 --> 00:12:20,000
page, also click on next, and the next page which is 

186
00:12:20,000 --> 00:12:24,000
about networking, leave all the default settings, so, 

187
00:12:24,000 --> 00:12:28,000
let's go to the next page, now we should set a password for the root for 

188
00:12:28,000 --> 00:12:32,000
the admin user. So, click on next, 

189
00:12:32,000 --> 00:12:36,000
and in this box, type a password for the admin user. 

190
00:12:36,000 --> 00:12:40,000
Alright, and then 

191
00:12:40,000 --> 00:12:44,000
let's go to the next page, once again leave all the default settings, 

192
00:12:44,000 --> 00:12:48,000
and click on next, and execute one more time, 

193
00:12:48,000 --> 00:12:52,000
alright, and now 

194
00:12:52,000 --> 00:12:56,000
let's finish our installation, once again we have to click on next, 

195
00:12:56,000 --> 00:13:00,000
and then finish. One more time, 

196
00:13:00,000 --> 00:13:04,000
there are so many steps. Now here's the page where you need to enter the

197
00:13:04,000 --> 00:13:08,000
admin password, so the page is called connect to server, you can

198
00:13:08,000 --> 00:13:12,000
see the username is root, which represents the admin user, 

199
00:13:12,000 --> 00:13:16,000
so in this box enter the password that you said earlier, 

200
00:13:16,000 --> 00:13:20,000
then click on check, okay, connection was successful 

201
00:13:20,000 --> 00:13:24,000
beautiful, let's go to the next page, and 

202
00:13:24,000 --> 00:13:28,000
click on execute, and finally finish. 

203
00:13:28,000 --> 00:13:32,000
There you go, we have one more step, next the 

204
00:13:32,000 --> 00:13:36,000
finally after all these steps the installation is complete.

205
00:13:36,000 --> 00:13:40,000
Now, this is going to start, MySQL workbench, which is the graphical

206
00:13:40,000 --> 00:13:44,000
tool we use to manage our database and run SQL queries. 

207
00:13:44,000 --> 00:13:48,000
So, click on finish, so now we have a command 

208
00:13:48,000 --> 00:13:52,000
prompt window, where we can type instructions to talk to our MySQL server, 

209
00:13:52,000 --> 00:13:56,000
we don't really need this, so close it, 

210
00:13:56,000 --> 00:14:00,000
and here's MySQL workbench, now the first time you open this page, 

211
00:14:00,000 --> 00:14:04,000
by default you should see a connection here, if you don't see it, 

212
00:14:04,000 --> 00:14:08,000
click on this plus icon, 

213
00:14:08,000 --> 00:14:12,000
on this page give this connection a name, let's say local 

214
00:14:12,000 --> 00:14:16,000
instance, now leave all their settings to their default value, 

215
00:14:16,000 --> 00:14:20,000
but here for the password click on store involved. 

216
00:14:20,000 --> 00:14:24,000
And in this box, type the password that you used for the admin user. 

217
00:14:24,000 --> 00:14:28,000
So, I'm going to put that here, okay, 

218
00:14:28,000 --> 00:14:32,000
now click on test connection, 

219
00:14:32,000 --> 00:14:36,000
alright, we successfully connected to the MySQL server on this 

220
00:14:36,000 --> 00:14:40,000
computer, alright, then, click on okay, 

221
00:14:40,000 --> 00:14:44,000
now we click on this connection to connect to our database server. 

222
00:14:44,000 --> 00:14:48,000
Alright, so here's the interface you'll be using throughout this course, 

223
00:14:48,000 --> 00:14:52,000
on the left hand side we have the navigator panel, in the middle we have the

224
00:14:52,000 --> 00:14:56,000
query editor which we can resize 

225
00:14:56,000 --> 00:15:00,000
this is where we're going to write our SQL queries, and on the right side we have 

226
00:15:00,000 --> 00:15:04,000
additions. So we're done with MySQL 

227
00:15:04,000 --> 00:15:08,000
on our computer, next, I'm going to show you how to create our databases for this query. 

228
00:15:08,000 --> 00:15:12,000


229
00:15:12,000 --> 00:15:16,000
In this tutorial, I'm going to show you how to

230
00:15:16,000 --> 00:15:20,000
create the databases for this course. So here I've got MySQL

231
00:15:20,000 --> 00:15:24,000
workbench open, let me quickly give you an overview of this interface because 

232
00:15:24,000 --> 00:15:28,000
the first time you open it it might appear a little bit intimidating. 

233
00:15:28,000 --> 00:15:32,000
But actually it's not that difficult. So here on the top we have this tool

234
00:15:32,000 --> 00:15:36,000
bar with these buttons for creating a new tab for writing SQL code 

235
00:15:36,000 --> 00:15:40,000
as well as opening a SQL file. And next to that 

236
00:15:40,000 --> 00:15:44,000
we've got a bunch of buttons for creating a database, creating new tables and 

237
00:15:44,000 --> 00:15:48,000
so on. On the left side, we've got the navigator panel with two tabs 

238
00:15:48,000 --> 00:15:52,000
administration and schemas. We use the administration tab

239
00:15:52,000 --> 00:15:56,000
to do administrative work, such as starting or stopping our server.

240
00:15:56,000 --> 00:16:00,000
Importing or exporting data and so on. The schemas 

241
00:16:00,000 --> 00:16:04,000
tab shows the databases that we have in the current database server. 

242
00:16:04,000 --> 00:16:08,000
So currently we only have one database, that is sis, and this is

243
00:16:08,000 --> 00:16:12,000
the database that MySQL uses internally to do it's work. 

244
00:16:12,000 --> 00:16:16,000
Now, in the middle we've got this query editor window, this is where we write our

245
00:16:16,000 --> 00:16:20,000
SQL code, so we'll be spending most of our time in this course, in this

246
00:16:20,000 --> 00:16:24,000
window, and on the right side we've got another panel with two tabs, 

247
00:16:24,000 --> 00:16:28,000
contacts held, and snippets, now chances are this interface 

248
00:16:28,000 --> 00:16:32,000
might look slightly different on Windows, but what I'm showing you here is 

249
00:16:32,000 --> 00:16:36,000
almost identical to what we have on Windows. So don't get hung up if it 

250
00:16:36,000 --> 00:16:40,000
looks slightly different on your machine. It doesn't really matter. Now up here, 

251
00:16:40,000 --> 00:16:44,000
we've got these buttons for showing or hiding these panels, so

252
00:16:44,000 --> 00:16:48,000
to clean this interface, I'm going to hide this panel on the right side. 

253
00:16:48,000 --> 00:16:52,000
As well as the panel on the bottom. That is better. Now, 

254
00:16:52,000 --> 00:16:56,000
to create the databases for this course, download the zip file attached, 

255
00:16:56,000 --> 00:17:00,000
below this video. When you extract the (?) you're going to see a bunch of

256
00:17:00,000 --> 00:17:04,000
SQL files like this. So the main one you'll be using in this tutorial

257
00:17:04,000 --> 00:17:08,000
is called create databases.SQL. So this

258
00:17:08,000 --> 00:17:12,000
file contains all the SQL code to create all the databases that we need 

259
00:17:12,000 --> 00:17:16,000
in this course, now we also have individual files for creating 

260
00:17:16,000 --> 00:17:20,000
individual databases, I've just added these files in case you need to recreate 

261
00:17:20,000 --> 00:17:24,000
one of these databases in the future. But for now don't worry about them. Now, 

262
00:17:24,000 --> 00:17:28,000
back to MySQL work bench, let's open 

263
00:17:28,000 --> 00:17:32,000
the main SQL file. That is create databases. 

264
00:17:32,000 --> 00:17:36,000
So this is an example of SQL code. 

265
00:17:36,000 --> 00:17:40,000
Now this may look complex at the beginning, but trust me, as you go through the course 

266
00:17:40,000 --> 00:17:44,000
you're going to understand exactly how everything works here. You're going to be able to

267
00:17:44,000 --> 00:17:48,000
write SQL code like this. So, you want to execute 

268
00:17:48,000 --> 00:17:52,000
this, to create all the databases for this course. To do that, we click 

269
00:17:52,000 --> 00:17:56,000
on this icon, this yellow thunder icon that we have 

270
00:17:56,000 --> 00:18:00,000
on this tool bar here. This will execute either the selection or the 

271
00:18:00,000 --> 00:18:04,000
entire code if there is nothing selected for example, if I select this line here, 

272
00:18:04,000 --> 00:18:08,000
and click on this icon, this will execute only this line. In this case

273
00:18:08,000 --> 00:18:12,000
we want to execute the entire code, so we shouldn't select anything, 

274
00:18:12,000 --> 00:18:16,000
and now let's execute this, beautiful, now here down on the bottom, 

275
00:18:16,000 --> 00:18:20,000
we have this panel called the output window that shows all the 

276
00:18:20,000 --> 00:18:24,000
operations perform in our database server, so we can see 

277
00:18:24,000 --> 00:18:28,000
all the operations completed successfully, or something went wrong. 

278
00:18:28,000 --> 00:18:32,000
As you can see you've got these green ticks next to each operation. 

279
00:18:32,000 --> 00:18:36,000
Beautiful, so I'm going to close this panel, that's better. 

280
00:18:36,000 --> 00:18:40,000
Now on the left side in this schemas tab you don't see this new database 

281
00:18:40,000 --> 00:18:44,000
so we'll have to refresh this view, beautiful. 

282
00:18:44,000 --> 00:18:48,000
So we've got all these databases that are prefixed with SQL

283
00:18:48,000 --> 00:18:52,000
or SQL, I decided to prefix them with SQL so we know that 

284
00:18:52,000 --> 00:18:56,000
these are the databases for this course, they don't accidentally clash with 

285
00:18:56,000 --> 00:19:00,000
a database on the same name of your database server. Now, 

286
00:19:00,000 --> 00:19:04,000
at the time of recording this video, there are only 4 databases here, but as we go through 

287
00:19:04,000 --> 00:19:08,000
the course, I'm going to update the script for creating the databases, so, 

288
00:19:08,000 --> 00:19:12,000
when you watch this course, chances are you're going to see more databases here. Don't worry 

289
00:19:12,000 --> 00:19:16,000
worry about the difference. Now as an example let's explore 

290
00:19:16,000 --> 00:19:20,000
these databases. And by the way we don't need this tab anymore so let's close it. 

291
00:19:20,000 --> 00:19:24,000
That's better. Let's expand the SQL store

292
00:19:24,000 --> 00:19:28,000
database, now in every database we have these objects, we have 

293
00:19:28,000 --> 00:19:32,000
tables, this is where we store our data, we have views, 

294
00:19:32,000 --> 00:19:36,000
which are kind of like virtual cables, so we can combine data from multiple 

295
00:19:36,000 --> 00:19:40,000
tables, and put them in a view. And this is especially powerful 

296
00:19:40,000 --> 00:19:44,000
for creating reports, you're going to learn about them in the future. You also have 

297
00:19:44,000 --> 00:19:48,000
store procedures and functions, and these are little programs that we 

298
00:19:48,000 --> 00:19:52,000
stored inside of our database for querying data. For example, 

299
00:19:52,000 --> 00:19:56,000
you can have a store procedure for getting all the customers in a given city. 

300
00:19:56,000 --> 00:20:00,000
So we call that procedure and we say hey, give me all the customers in San Francisco 

301
00:20:00,000 --> 00:20:04,000
And this will return all the customers in San Francisco. 

302
00:20:04,000 --> 00:20:08,000
Okay, now, let's expand the tables, 

303
00:20:08,000 --> 00:20:12,000
so here are the tables in this database. We have customers, 

304
00:20:12,000 --> 00:20:16,000
we have orders, products, shippers and so on. 

305
00:20:16,000 --> 00:20:20,000
Now, select this customers table whenever you hover your mouse 

306
00:20:20,000 --> 00:20:24,000
over this item and see these three items on the right side. 

307
00:20:24,000 --> 00:20:28,000
Click on the right most icon, that looks like a table with a 

308
00:20:28,000 --> 00:20:32,000
thunder. With this we can see all the data, in this 

309
00:20:32,000 --> 00:20:36,000
table. So this is our customers table. In this

310
00:20:36,000 --> 00:20:40,000
table, we have these columns like customer id which we use to uniquely identify 

311
00:20:40,000 --> 00:20:44,000
customers. We all have first name, last name, birth 

312
00:20:44,000 --> 00:20:48,000
date, phone, address and so on. So these are the columns 

313
00:20:48,000 --> 00:20:52,000
in this table and every row is called a 

314
00:20:52,000 --> 00:20:56,000
record. So every row represents one customer and these are the pieces of 

315
00:20:56,000 --> 00:21:00,000
information we know for each customer. Now let's look at 

316
00:21:00,000 --> 00:21:04,000
another table, let's open the orders table, 

317
00:21:04,000 --> 00:21:08,000
in this table we have these columns like order ID, customer ID, 

318
00:21:08,000 --> 00:21:12,000
order date, status, and so on. What is this customer ID here. 

319
00:21:12,000 --> 00:21:16,000
We use this column to identify who has placed 

320
00:21:16,000 --> 00:21:20,000
each order. Now what is interesting here is you have referred to this customer 

321
00:21:20,000 --> 00:21:24,000
using their customer ID which uniquely identifies that. 

322
00:21:24,000 --> 00:21:28,000
In other words, if Jon Smith has placed an order, we don't 

323
00:21:28,000 --> 00:21:32,000
store John Smith here, we only store John's customer ID. 

324
00:21:32,000 --> 00:21:36,000
Why is that? Here is the reason. It is possible 

325
00:21:36,000 --> 00:21:40,000
John Smith might have placed multiple orders in our system. 

326
00:21:40,000 --> 00:21:44,000
Now every time John places his order, we need to look up his address and 

327
00:21:44,000 --> 00:21:48,000
phone to ship his order. Now it is possible that some of this information 

328
00:21:48,000 --> 00:21:52,000
might change in the future. John might move to a new place or change his 

329
00:21:52,000 --> 00:21:56,000
phone number, he might even change his name, if you repeat all that information

330
00:21:56,000 --> 00:22:00,000
next to each order, then we'll have to come back and make changes

331
00:22:00,000 --> 00:22:04,000
in multiple places. In contrast, with this design we only 

332
00:22:04,000 --> 00:22:08,000
store the ID of john here, so anytime we want to change 

333
00:22:08,000 --> 00:22:12,000
any information about John, instead of changing that here. We go back

334
00:22:12,000 --> 00:22:16,000
to our customers table, so let's look at 

335
00:22:16,000 --> 00:22:20,000
customer with ID 6, that is actually called (?)

336
00:22:20,000 --> 00:22:24,000
So here is all the information about Elka. This is her phone number, this is

337
00:22:24,000 --> 00:22:28,000
her address, and by the way this is all dummy data that I created using a tool. 

338
00:22:28,000 --> 00:22:32,000
So, if any information about elka changes in the future, 

339
00:22:32,000 --> 00:22:36,000
this is the only place that we need to modify. So 

340
00:22:36,000 --> 00:22:40,000
this is how these databases work. We refer to these databases as 

341
00:22:40,000 --> 00:22:44,000
relational databases. That basically means in these kind of databases we have 

342
00:22:44,000 --> 00:22:48,000
multiple tables that are related to each other using 

343
00:22:48,000 --> 00:22:52,000
a relationship. So internally there is a relationship between

344
00:22:52,000 --> 00:22:56,000
the customers table, and the orders table. So the customer 

345
00:22:56,000 --> 00:23:00,000
ID column in the customers table is related 

346
00:23:00,000 --> 00:23:04,000
or linked or associated with the customer ID column. 

347
00:23:04,000 --> 00:23:08,000
In the orders table. Here's the orders table, and here we have 

348
00:23:08,000 --> 00:23:12,000
the customer ID column. So this was a brief introduction to 

349
00:23:12,000 --> 00:23:16,000
relational databases, you learned about databases, tables, 

350
00:23:16,000 --> 00:23:20,000
columns, rows and relationships. In the next section I'm going to show you

351
00:23:20,000 --> 00:23:24,000
how to retrieve data from a single table in this database. 

352
00:23:24,000 --> 00:23:28,000
But, before going any further as an exercise I want you to explore 

353
00:23:28,000 --> 00:23:32,000
the invoicing database. Look at the all the tables, look at all the data to

354
00:23:32,000 --> 00:23:36,000
get an id of the kind of data that we have in this database. You're going to use this database 

355
00:23:36,000 --> 00:23:40,000
a lot in the future, so let's spend a couple minutes to explore this

356
00:23:40,000 --> 00:23:44,000
database. 

357
00:23:44,000 --> 00:23:48,000
In this tutorial I'm going to show you how 

358
00:23:48,000 --> 00:23:52,000
to retrieve data from a single panel. Now look at the navigator panel. 

359
00:23:52,000 --> 00:23:56,000
Currently none of our databases is displayed in bold, and that

360
00:23:56,000 --> 00:24:00,000
means none of these databases are selected for query. So the first step to

361
00:24:00,000 --> 00:24:04,000
rate a query to get data from a database, is to select a database. 

362
00:24:04,000 --> 00:24:08,000
The query that we'll write will be executed against that database. 

363
00:24:08,000 --> 00:24:12,000
In this demo, we're going to use the SEQUEL store database. 

364
00:24:12,000 --> 00:24:16,000
So we type our use SQL_

365
00:24:16,000 --> 00:24:20,000
store. Now use is a keyword in the SQL language, and that's 

366
00:24:20,000 --> 00:24:24,000
displayed in blue. Now SQL is not a case sensitive language, 

367
00:24:24,000 --> 00:24:28,000
and that means we can use upper case or lower case characters, it doesn't really 

368
00:24:28,000 --> 00:24:32,000
matter, but as a best practice, we should capitalize the 

369
00:24:32,000 --> 00:24:36,000
SQL keywords, and use lower case characters for everything else. 

370
00:24:36,000 --> 00:24:40,000
So now, let's go ahead and execute this query. Alright, 

371
00:24:40,000 --> 00:24:44,000
Look, the SQL store database is now displayed in bold. 

372
00:24:44,000 --> 00:24:48,000
Now in MySQL workbench, we can also select a database 

373
00:24:48,000 --> 00:24:52,000
by double clicking that, so now I double click SQL invoice 

374
00:24:52,000 --> 00:24:56,000
and it's the current database. Now if we run this query again, 

375
00:24:56,000 --> 00:25:00,000
the SQL store database becomes selected. 

376
00:25:00,000 --> 00:25:04,000
Alright, now let's write our first query to retrieve all the customers in this

377
00:25:04,000 --> 00:25:08,000
database. So after the you statement we're going to use 

378
00:25:08,000 --> 00:25:12,000
select statement. Here is the basic syntax or basic structure 

379
00:25:12,000 --> 00:25:16,000
of the select statement, we type out select in front 

380
00:25:16,000 --> 00:25:20,000
of that we specify the columns that we want to retrieve, for example we can retrieve 

381
00:25:20,000 --> 00:25:24,000
the customer ID column as well as the first name column or 

382
00:25:24,000 --> 00:25:28,000
we can retrieve all columns using an asterisk. 

383
00:25:28,000 --> 00:25:32,000
Now after that we use the from clause and this is where we specify the 

384
00:25:32,000 --> 00:25:36,000
table that we want to query, in this case the customer's table. 

385
00:25:36,000 --> 00:25:40,000
So this is the simplest query to select all the customers in a given table, 

386
00:25:40,000 --> 00:25:44,000
now whenever you have multiple SQL statements you

387
00:25:44,000 --> 00:25:48,000
need to terminate each statement using a semicolon. So, 

388
00:25:48,000 --> 00:25:52,000
look, we have a red underline here that indicates an error, if you hover your mouse over here, 

389
00:25:52,000 --> 00:25:56,000
you can see this tool tip saying select is not valid at this position. 

390
00:25:56,000 --> 00:26:00,000
Because we didn't terminate the first statement with a semi colon. 

391
00:26:00,000 --> 00:26:04,000
Okay, now let's execute this query one more time, once again, 

392
00:26:04,000 --> 00:26:08,000
we can click on this button here, or we can use a short cut, 

393
00:26:08,000 --> 00:26:12,000
so look at the query menu on the top, the first line is execute.

394
00:26:12,000 --> 00:26:16,000
Now here's the shortcut for this command, on Mac, it's shift 

395
00:26:16,000 --> 00:26:20,000
command and enter. On Windows its going to be different honestly 

396
00:26:20,000 --> 00:26:24,000
I'm not sure. So whatever it is, use that. So I'm going to press 

397
00:26:24,000 --> 00:26:28,000
shift command enter, and here are 

398
00:26:28,000 --> 00:26:32,000
all the customers in this table. So this 

399
00:26:32,000 --> 00:26:36,000
next statement has two clauses, the select clause and the 

400
00:26:36,000 --> 00:26:40,000
from clause. But there are other clauses we can use to filter 

401
00:26:40,000 --> 00:26:44,000
and sort data. For example, you can use the wear clause 

402
00:26:44,000 --> 00:26:48,000
to filter the result and get the customer with ID

403
00:26:48,000 --> 00:26:52,000
one. So we can write an expression like this. Where 

404
00:26:52,000 --> 00:26:56,000
_ID = 1. Now when we execute this 

405
00:26:56,000 --> 00:27:00,000
query, we'll only get the customer with ID 

406
00:27:00,000 --> 00:27:04,000
1. So this is the where clause. We can also sort 

407
00:27:04,000 --> 00:27:08,000
the data so after wear we use the order by 

408
00:27:08,000 --> 00:27:12,000
clause and here we specify the columns that we're going to sort the results from

409
00:27:12,000 --> 00:27:16,000
on. Let's say we want to sort these customers by their first name so we type out 

410
00:27:16,000 --> 00:27:20,000
first_name. That is the name of one of the columns in this 

411
00:27:20,000 --> 00:27:24,000
table, right? Now if you execute this query this order by doesn't really have 

412
00:27:24,000 --> 00:27:28,000
an impact, because we only get one record in the result 

413
00:27:28,000 --> 00:27:32,000
so let me temporarily take out the where clause, 

414
00:27:32,000 --> 00:27:36,000
to do that we can put two hyphens in front of this line, now this line, 

415
00:27:36,000 --> 00:27:40,000
is treated as a comment, which means the SQL engine is not going to

416
00:27:40,000 --> 00:27:44,000
execute this, okay, so let's execute this query one more time, 

417
00:27:44,000 --> 00:27:48,000
now all the customers that we get our sorted 

418
00:27:48,000 --> 00:27:52,000
based on their first name. So that's the basic idea. 

419
00:27:52,000 --> 00:27:56,000
Now over the next few tutorials your'e going to learn more about

420
00:27:56,000 --> 00:28:00,000
these clauses in detail. But what you need to take away in this tutorial is that 

421
00:28:00,000 --> 00:28:04,000
is that these 3 clauses from where an order by are 

422
00:28:04,000 --> 00:28:08,000
optional. As you can see in this example, I'm not using the where clause, 

423
00:28:08,000 --> 00:28:12,000
we can also comment out the order by clause, we can also comment 

424
00:28:12,000 --> 00:28:16,000
out the from clause, so instead of selecting all the columns, 

425
00:28:16,000 --> 00:28:20,000
in a given table, we can select some values like one and two. Now, 

426
00:28:20,000 --> 00:28:24,000
if you execute this query one more time, in the result, we get something like

427
00:28:24,000 --> 00:28:28,000
this. Two columns called one and two, and in these columns 

428
00:28:28,000 --> 00:28:32,000
we have these values. So all these clauses are optional but in the 

429
00:28:32,000 --> 00:28:36,000
real world we quite often use all of them. Now what you need to understand here is that 

430
00:28:36,000 --> 00:28:40,000
the order of these clauses matter, so we always have select first, 

431
00:28:40,000 --> 00:28:44,000
then we have from, then where, and finally order by. 

432
00:28:44,000 --> 00:28:48,000
We cannot change the order of these clauses, otherwise we get a syntax error. 

433
00:28:48,000 --> 00:28:52,000
Which basically means the syntax, or the grammar or the structure 

434
00:28:52,000 --> 00:28:56,000
of our simple statement is incorrect. So it cannot be executed. 

435
00:28:56,000 --> 00:29:00,000
And one last thing before we finish this tutorial, you can

436
00:29:00,000 --> 00:29:04,000
see I've listed all these clauses on a  new line, now technically you don't have to

437
00:29:04,000 --> 00:29:08,000
do this, because line breaks, white spaces and tabs are ignored 

438
00:29:08,000 --> 00:29:12,000
when executing SQL statements. So we could come back here and 

439
00:29:12,000 --> 00:29:16,000
put from in front of select, so select store 

440
00:29:16,000 --> 00:29:20,000
from customers all in one line, and that's perfectly acceptable for simple queries, 

441
00:29:20,000 --> 00:29:24,000
but as your queries get more complex, it's better to put each clause

442
00:29:24,000 --> 00:29:28,000
on a new line. So that's all for this tutorial. In the next 

443
00:29:28,000 --> 00:29:32,000
tutorial, we'll explore the select  clause in detail. 

444
00:29:32,000 --> 00:29:36,000


445
00:29:36,000 --> 00:29:40,000
In this tutorial, we're going to look at the select clause in detail. 

446
00:29:40,000 --> 00:29:44,000
So, since our current database is SQL store, to 

447
00:29:44,000 --> 00:29:48,000
clean things up I'm going to remove the first statement, you don't really need it now, 

448
00:29:48,000 --> 00:29:52,000
also, I'm going to delete these two comments, we just want 

449
00:29:52,000 --> 00:29:56,000
to focus on the select clause. Alright, so what

450
00:29:56,000 --> 00:30:00,000
can we do with this select clause? Well in the last tutorial we learned that if you use 

451
00:30:00,000 --> 00:30:04,000
an asterisk, this will return all the columns. Alternatively we can specify 

452
00:30:04,000 --> 00:30:08,000
the columns that we want and this is helpful in situations where you have a 

453
00:30:08,000 --> 00:30:12,000
big table with so many columns and perhaps millions of record. 

454
00:30:12,000 --> 00:30:16,000
If you want to bring back all that data, that's going to put a lot of pressure 

455
00:30:16,000 --> 00:30:20,000
on the database server, in this case MySQL, as well as the network. 

456
00:30:20,000 --> 00:30:24,000
So, that's when we explicitly specify the columns that we 

457
00:30:24,000 --> 00:30:28,000
want to get. Let's say we want to get the first name 

458
00:30:28,000 --> 00:30:32,000
and last name columns. Execute

459
00:30:32,000 --> 00:30:36,000
the query, as you can see, we only get these two columns. 

460
00:30:36,000 --> 00:30:40,000
And they are in the same order we specified here. So if we 

461
00:30:40,000 --> 00:30:44,000
change the order and put the last name first and execute the 

462
00:30:44,000 --> 00:30:48,000
query again, now we can see the last name column comes first. 

463
00:30:48,000 --> 00:30:52,000
Now let's add a new column, at the end, let's get

464
00:30:52,000 --> 00:30:56,000
the points for each customer as well, run the query, so these are

465
00:30:56,000 --> 00:31:00,000
the points for each customer which are calculated based on their shopping. 

466
00:31:00,000 --> 00:31:04,000
Now let's say we want to get these points and put them in a mathematical formula 

467
00:31:04,000 --> 00:31:08,000
to calculate the discount that we can give to each customer. 

468
00:31:08,000 --> 00:31:12,000
So here we can use an arithmetic expression, that's points plus ten. 

469
00:31:12,000 --> 00:31:16,000
This is an arithmetic expression. So now we can execute this query 

470
00:31:16,000 --> 00:31:20,000
for the first record you can see that their points will end up

471
00:31:20,000 --> 00:31:24,000
being 2283. Let's run the query one more time

472
00:31:24,000 --> 00:31:28,000
there you go. Now we can put the original points column here for clarity. 

473
00:31:28,000 --> 00:31:32,000
So points, points plus 10. Let's run the

474
00:31:32,000 --> 00:31:36,000
query one more time, now you can see the original points, and next 

475
00:31:36,000 --> 00:31:40,000
to that you can see the value that we're going to use to calculate the discount. 

476
00:31:40,000 --> 00:31:44,000
Now here we're using the plus operator which is for addition, we also have 

477
00:31:44,000 --> 00:31:48,000
multiplication, division, subtraction, and 

478
00:31:48,000 --> 00:31:52,000
module which is the remainder of the division. So let's change this to something 

479
00:31:52,000 --> 00:31:56,000
more complex. Let's say we want to get the points, multiply by 10, 

480
00:31:56,000 --> 00:32:00,000
and then add 100 to it. 

481
00:32:00,000 --> 00:32:04,000
Now we can immediately see that this line one is getting too long 

482
00:32:04,000 --> 00:32:08,000
and it doesn't fit on the screen, in situations like this, you can break

483
00:32:08,000 --> 00:32:12,000
up the select clause by placing each column on a new line, so, 

484
00:32:12,000 --> 00:32:16,000
select last name, then first name 

485
00:32:16,000 --> 00:32:20,000
points finally points times 10, 

486
00:32:20,000 --> 00:32:24,000
plus 100. So let's execute this query one more time. 

487
00:32:24,000 --> 00:32:28,000
So this is our new column with the new calculated value. 

488
00:32:28,000 --> 00:32:32,000
Now one thing you need to understand in this arithmetic expression is the order 

489
00:32:32,000 --> 00:32:36,000
of operators, and this is based on the order of operators in math. 

490
00:32:36,000 --> 00:32:40,000
So in math, the multiplication and division 

491
00:32:40,000 --> 00:32:44,000
operators have nighter precedence then addition

492
00:32:44,000 --> 00:32:48,000
and subtraction, so in this expression, points is

493
00:32:48,000 --> 00:32:52,000
multiplied by 10 and then the result is added 

494
00:32:52,000 --> 00:32:56,000
to 100. If this is not what you want you can always change the order

495
00:32:56,000 --> 00:33:00,000
by using parenthesis, as an example, let's change this

496
00:33:00,000 --> 00:33:04,000
multiplication to addition and then put that 

497
00:33:04,000 --> 00:33:08,000
multiplication here. In this expression, first 10 is 

498
00:33:08,000 --> 00:33:12,000
multiplied by 100, and then the result is added to the points. 

499
00:33:12,000 --> 00:33:16,000
Now let's say this is not what we want, so we can change the order by

500
00:33:16,000 --> 00:33:20,000
using parenthesis here. 

501
00:33:20,000 --> 00:33:24,000
With these parenthesis, first we get the points add 10 to them 

502
00:33:24,000 --> 00:33:28,000
and then multiply the result by 100. So this

503
00:33:28,000 --> 00:33:32,000
parenthesis are useful for changing the order of operations as well as 

504
00:33:32,000 --> 00:33:36,000
adding clarity to our code. So someone else reading this code can easily understand. 

505
00:33:36,000 --> 00:33:40,000
the order of these operations. Now let's execute this query one more time, 

506
00:33:40,000 --> 00:33:44,000
alright, now look at the name of this column here, 

507
00:33:44,000 --> 00:33:48,000
its set to the expression that we have on line 5. 

508
00:33:48,000 --> 00:33:52,000
That doesn't quite make sense you want to have a clear descriptive name, 

509
00:33:52,000 --> 00:33:56,000
so we can give this column an alias using the as keyword. 

510
00:33:56,000 --> 00:34:00,000
So, as and then we give it a name like discount 

511
00:34:00,000 --> 00:34:04,000
discount _factor. Let's run the query again. 

512
00:34:04,000 --> 00:34:08,000
now the name of this column has changed, so this is the 

513
00:34:08,000 --> 00:34:12,000
benefit of using an alias, we can give descriptive names to the 

514
00:34:12,000 --> 00:34:16,000
columns and the results sets. Now if you want to have a space in the 

515
00:34:16,000 --> 00:34:20,000
column name, you need to surround it with quotes, either 

516
00:34:20,000 --> 00:34:24,000
single, or double quotes. So we put quotes here and then 

517
00:34:24,000 --> 00:34:28,000
we can add a space in between these two words. Let me 

518
00:34:28,000 --> 00:34:32,000
execute the query one more time. Now we have discount

519
00:34:32,000 --> 00:34:36,000
factor. So let's quickly recap everything you learned about the select 

520
00:34:36,000 --> 00:34:40,000
clause. We cause an asterisk to return the columns, or 

521
00:34:40,000 --> 00:34:44,000
we can explicitly specify the columns that you want to return. 

522
00:34:44,000 --> 00:34:48,000
We can also use, arithmetic expressions here, and optionally, we can even

523
00:34:48,000 --> 00:34:52,000
 gibe an alias to each column in the results set. Now there is one more

524
00:34:52,000 --> 00:34:56,000
thing you need to know about the select clause. So let's delete this query 

525
00:34:56,000 --> 00:35:00,000
and select the state column, 

526
00:35:00,000 --> 00:35:04,000
of the customers table. Take a look. These are the 

527
00:35:04,000 --> 00:35:08,000
states in which our customers our located. Now currently in the sample 

528
00:35:08,000 --> 00:35:12,000
data we don't have any duplicates, in other words we don't have multiple customer

529
00:35:12,000 --> 00:35:16,000
in any of these states. But for this demo I want to change the 

530
00:35:16,000 --> 00:35:20,000
state of the first customer to Virginia, so we end up with duplicates 

531
00:35:20,000 --> 00:35:24,000
in the result set. So let's open up navigator panel

532
00:35:24,000 --> 00:35:28,000
here's our customers table, let's look at all the data, 

533
00:35:28,000 --> 00:35:32,000
and here's our first customer, 

534
00:35:32,000 --> 00:35:36,000
here a you can see, it's located in the state of Massachusetts 

535
00:35:36,000 --> 00:35:40,000
now I want to change this to Virginia. So double click

536
00:35:40,000 --> 00:35:44,000
VA for Virginia, enter, now 

537
00:35:44,000 --> 00:35:48,000
on the bottom right corner of the screen, you should see two buttons, 

538
00:35:48,000 --> 00:35:52,000
apply and revert. Unfortunately I cannot show you this button 

539
00:35:52,000 --> 00:35:56,000
because the recording window is a bit smaller then MySQL 

540
00:35:56,000 --> 00:36:00,000
But look down in the bottom right hand corner, click

541
00:36:00,000 --> 00:36:04,000
and apply. You're going to see a dial up box like this asking you to

542
00:36:04,000 --> 00:36:08,000
review the changes, so go ahead and click that button one more time

543
00:36:08,000 --> 00:36:12,000
alright, now, let's

544
00:36:12,000 --> 00:36:16,000
go back to our first query window, and execute this query one more time. 

545
00:36:16,000 --> 00:36:20,000
As you can see, the first two customers are located

546
00:36:20,000 --> 00:36:24,000
in Virginia. What if you wanted to get a unique list of

547
00:36:24,000 --> 00:36:28,000
states in the results set, that's when we use a distinct 

548
00:36:28,000 --> 00:36:32,000
keyword. So select distinct set. 

549
00:36:32,000 --> 00:36:36,000
With his query, we'll retrieve a unique list of states from the 

550
00:36:36,000 --> 00:36:40,000
customers table. So with the distinct keyword we can remove 

551
00:36:40,000 --> 00:36:44,000
let's execute the query one more time, now you can see

552
00:36:44,000 --> 00:36:48,000
Virginia is not duplicated. 

553
00:36:48,000 --> 00:36:52,000
Alright here's an exercise for you. 

554
00:36:52,000 --> 00:36:56,000
I want you to write a SQL query to return all the products in our database 

555
00:36:56,000 --> 00:37:00,000
in the result set. I want to see three columns, name, 

556
00:37:00,000 --> 00:37:04,000
unit price, and a new column called new

557
00:37:04,000 --> 00:37:08,000
price which is based on this expression, unit price 

558
00:37:08,000 --> 00:37:12,000
times 1.1. So let's say you want to increase the price of each product by

559
00:37:12,000 --> 00:37:16,000
10%. With this query you want to get all the products 

560
00:37:16,000 --> 00:37:20,000
the original price and the new price. So pause the video and spend 

561
00:37:20,000 --> 00:37:24,000
one or two minutes on this exercise, when you are done come back and see my solution. 

562
00:37:24,000 --> 00:37:28,000


563
00:37:28,000 --> 00:37:32,000
Alright this is pretty easy, so we start with select 

564
00:37:32,000 --> 00:37:36,000
now what columns do we want to select? Name, unit

565
00:37:36,000 --> 00:37:40,000
_price and then here we're going to use an arithmetic 

566
00:37:40,000 --> 00:37:44,000
expression to calculate the new price. So we type 

567
00:37:44,000 --> 00:37:48,000
out unit price times 1.1 and then give it a 

568
00:37:48,000 --> 00:37:52,000
alias, o as new_price or we can put this in quotes 

569
00:37:52,000 --> 00:37:56,000
and put a space between new and price. Now where do we want to

570
00:37:56,000 --> 00:38:00,000
select these columns from? From the products table, so from 

571
00:38:00,000 --> 00:38:04,000
products. Note that I've used upper case characters for all

572
00:38:04,000 --> 00:38:08,000
the SQL keywords and lowercase characters for everything else. So, 

573
00:38:08,000 --> 00:38:12,000
let's go ahead and execute tis query, this is what we get 

574
00:38:12,000 --> 00:38:16,000
so these are all the products, you can see their original price 

575
00:38:16,000 --> 00:38:20,000
as well as the new price which is 10 % more expensive. 

576
00:38:20,000 --> 00:38:24,000


577
00:38:24,000 --> 00:38:28,000
In this tutorial, we're going to look at the where clause

578
00:38:28,000 --> 00:38:32,000
in SQL. So earlier I told you that we use the where clause to filter 

579
00:38:32,000 --> 00:38:36,000
data. For example, let's say we only want to get the customers with 

580
00:38:36,000 --> 00:38:40,000
points greater than 3000. So here in the where clause you can type out

581
00:38:40,000 --> 00:38:44,000
the condition like this. Points, greater than 

582
00:38:44,000 --> 00:38:48,000
3000. When we execute this query, the query execution

583
00:38:48,000 --> 00:38:52,000
engine in MySQL is going to iterate over all the customers 

584
00:38:52,000 --> 00:38:56,000
in the customers table. For each customer it's going to evaluate this condition 

585
00:38:56,000 --> 00:39:00,000
if this condition is true, it will return that customer in the 

586
00:39:00,000 --> 00:39:04,000
result set. So let's go ahead and execute this, 

587
00:39:04,000 --> 00:39:08,000
and here's the result, as you can see you only have two customers 

588
00:39:08,000 --> 00:39:12,000
with points greater than 3000. 

589
00:39:12,000 --> 00:39:16,000
So, thesis what we call the greater than operator which is one of the 

590
00:39:16,000 --> 00:39:20,000
comparison operators in SQL. Let me show you the completeness of comparison 

591
00:39:20,000 --> 00:39:24,000
operators, so, we have 

592
00:39:24,000 --> 00:39:28,000
greater than, greater than, or equal to, we have less then, 

593
00:39:28,000 --> 00:39:32,000
less than or equal to, here's the equality 

594
00:39:32,000 --> 00:39:36,000
operator, and for not equality, we can use an exclamation 

595
00:39:36,000 --> 00:39:40,000
followed by an equal sign, or something like this. So both 

596
00:39:40,000 --> 00:39:44,000
of these are not equal operators. Let me show you examples of 

597
00:39:44,000 --> 00:39:48,000
these operators. So I'm going to delete all these and bring back

598
00:39:48,000 --> 00:39:52,000
the previous query, let's say we want to get only the customers in the

599
00:39:52,000 --> 00:39:56,000
state of Virginia. So we can change our condition to something like this. 

600
00:39:56,000 --> 00:40:00,000
Where state equals Virginia. 

601
00:40:00,000 --> 00:40:04,000
Note that I've put Virginia in quotes, because this is what we call a 

602
00:40:04,000 --> 00:40:08,000
string. A string is a sequence of characters. So whenever you're dealing

603
00:40:08,000 --> 00:40:12,000
with a sequence of characters, or basically textural data, we 

604
00:40:12,000 --> 00:40:16,000
need to enclose your values with either single or double quotes. 

605
00:40:16,000 --> 00:40:20,000
But quite often, by convention, we use single quotes 

606
00:40:20,000 --> 00:40:24,000
so let's execute this query and here's

607
00:40:24,000 --> 00:40:28,000
the result, you can see we only have these two customers with ID 1

608
00:40:28,000 --> 00:40:32,000
and 2, who are located in Virginia. And it doesn't matter

609
00:40:32,000 --> 00:40:36,000
if you use upper case or lower case characters, so if you type out

610
00:40:36,000 --> 00:40:40,000
the a in lower case and execute the query you get the

611
00:40:40,000 --> 00:40:44,000
exact same result. Now what if you want to get all the customers 

612
00:40:44,000 --> 00:40:48,000
outside of the state of Virginia, you can use the not equal operator. 

613
00:40:48,000 --> 00:40:52,000
So, we can either prefix this with an exclamation 

614
00:40:52,000 --> 00:40:56,000
or use this other notation. 

615
00:40:56,000 --> 00:41:00,000
Either way we get the same result. So these are 

616
00:41:00,000 --> 00:41:04,000
the customers that are not located in Virginia. Now we can 

617
00:41:04,000 --> 00:41:08,000
use these comparison operators for date values as well. For example, 

618
00:41:08,000 --> 00:41:12,000
let's say you want to get only the customers born after January 

619
00:41:12,000 --> 00:41:16,000
1st, 1990. So we change out condition to

620
00:41:16,000 --> 00:41:20,000
first date, greater then, once again we use quotes, 

621
00:41:20,000 --> 00:41:24,000
for representing date values even though dates are actually not 

622
00:41:24,000 --> 00:41:28,000
strings. But in the sequel language, we should enclose dates with quotes, 

623
00:41:28,000 --> 00:41:32,000
so, here we type out 1990, 

624
00:41:32,000 --> 00:41:36,000
01 for January, -01 for

625
00:41:36,000 --> 00:41:40,000
date. So this is the standard or default format for representing 

626
00:41:40,000 --> 00:41:44,000
dates in MySQL. 4 digits for the year, two digits for the

627
00:41:44,000 --> 00:41:48,000
month, and 2 digits for the day. So let's go ahead and execute

628
00:41:48,000 --> 00:41:52,000
this query. I actually made a mistake here, so we don't see the 

629
00:41:52,000 --> 00:41:56,000
result, instead we see the action output, or the output window.

630
00:41:56,000 --> 00:42:00,000
If you scroll to the bottom, you can see the details of the error. So here I used 

631
00:42:00,000 --> 00:42:04,000
the wrong name for the column, which should separate these two words

632
00:42:04,000 --> 00:42:08,000
with an underscore. That is the name of our column. So, 

633
00:42:08,000 --> 00:42:12,000
let's execute the query one more time, so we only have 3 customers

634
00:42:12,000 --> 00:42:16,000
born after January 1st 1990. So these 

635
00:42:16,000 --> 00:42:20,000
are examples of comparison operators in SQL. In the next tutorial

636
00:42:20,000 --> 00:42:24,000
I'm going to show you how to combine multiple conditions when filtering data. 

637
00:42:24,000 --> 00:42:28,000


638
00:42:28,000 --> 00:42:32,000
Alright, here's your exercise. I want you to write a query to get the 

639
00:42:32,000 --> 00:42:36,000
orders that are placed this year, so look at the orders table, see

640
00:42:36,000 --> 00:42:40,000
what columns to do we have there, and based on that write query with a  where clause. 

641
00:42:40,000 --> 00:42:44,000


642
00:42:44,000 --> 00:42:48,000
So here's the orders table, in this table we have this column, order

643
00:42:48,000 --> 00:42:52,000
date. We can use this problem to see the orders that are placed this year 

644
00:42:52,000 --> 00:42:56,000
so here's our query, select, start from order 

645
00:42:56,000 --> 00:43:00,000
where order_date, is 

646
00:43:00,000 --> 00:43:04,000
greater than or equal to 2019, assuming 

647
00:43:04,000 --> 00:43:08,000
this is the current yer, so 2019, 0101. 

648
00:43:08,000 --> 00:43:12,000
Now since currently we are in the year 2019, this query will

649
00:43:12,000 --> 00:43:16,000
return all the orders placed this year. But next year this query 

650
00:43:16,000 --> 00:43:20,000
is not going to give us the right result. But don't worry about it, later in the course I will show

651
00:43:20,000 --> 00:43:24,000
you how to write a query to get the orders placed in the current year, 

652
00:43:24,000 --> 00:43:28,000
so for the purpose of the new exercise, this is a valid solution. Now let's

653
00:43:28,000 --> 00:43:32,000
execute this query and see what we get. So, we have 

654
00:43:32,000 --> 00:43:36,000
only one order, order ID 1, that is placed in the current 

655
00:43:36,000 --> 00:43:40,000
year. 

656
00:43:40,000 --> 00:43:44,000
In this tutorial I'm going to show you how to

657
00:43:44,000 --> 00:43:48,000
combine multiple search conditions when filtering data. So,

658
00:43:48,000 --> 00:43:52,000
let's say you want to get all the customers that were born after

659
00:43:52,000 --> 00:43:56,000
January 1st, 1990, who also happen to have more then 

660
00:43:56,000 --> 00:44:00,000
1000 points. So this is where we use the and operator. 

661
00:44:00,000 --> 00:44:04,000
So we type out and, and after we type out another condition. 

662
00:44:04,000 --> 00:44:08,000
Like points, greater than 1000. 

663
00:44:08,000 --> 00:44:12,000
Now when we execute this query, we only get customers who have 

664
00:44:12,000 --> 00:44:16,000
both these conditions. Let's take a look, so execute 

665
00:44:16,000 --> 00:44:20,000
we only have 2 customers and if you look both these people

666
00:44:20,000 --> 00:44:24,000
are born after 1990, and they have more then 

667
00:44:24,000 --> 00:44:28,000
1000 points. So this is the and operator. When we use this 

668
00:44:28,000 --> 00:44:32,000
operator, both these conditions should be true. In contrast to the and 

669
00:44:32,000 --> 00:44:36,000
operator, we have the or operator. So with or if

670
00:44:36,000 --> 00:44:40,000
at least one of these conditions is true, that row will be returned in the 

671
00:44:40,000 --> 00:44:44,000
result set. Let's take a look. Now we execute this query again, 

672
00:44:44,000 --> 00:44:48,000
2 records we have quite a few records. So for example, 

673
00:44:48,000 --> 00:44:52,000
we have this person who's not born after 1990 

674
00:44:52,000 --> 00:44:56,000
but if you look at their points they have more then 1000 points. 

675
00:44:56,000 --> 00:45:00,000
So any customer records that satisfies at least one of these conditions

676
00:45:00,000 --> 00:45:04,000
will be returned. Now let's take this to the next level. Let's say we want to get

677
00:45:04,000 --> 00:45:08,000
customers who are either born after 1990, or 

678
00:45:08,000 --> 00:45:12,000
they should have at least 1000 points and live in Virginia 

679
00:45:12,000 --> 00:45:16,000
so this is how we do this, we type out and 

680
00:45:16,000 --> 00:45:20,000
and then we add another condition, state equals 

681
00:45:20,000 --> 00:45:24,000
Virginia. Let's execute this query and see what we get. We only get

682
00:45:24,000 --> 00:45:28,000
4 records, so these are the customers that are either born after

683
00:45:28,000 --> 00:45:32,000
1990 or they have more then 1000 points and live 

684
00:45:32,000 --> 00:45:36,000
in Virginia. If you look at the first customer here this

685
00:45:36,000 --> 00:45:40,000
person is not born after 1990. But you can see that she lives

686
00:45:40,000 --> 00:45:44,000
in Virginia and she has more than 1000 points. So the last two conditions. 

687
00:45:44,000 --> 00:45:48,000
are true for this customer. Now when combining multiple

688
00:45:48,000 --> 00:45:52,000
logical operators. You need to be aware of the order of these operators. 

689
00:45:52,000 --> 00:45:56,000
So earlier I talked about he order of arithmetic operators. I told you that

690
00:45:56,000 --> 00:46:00,000
multiplication have a higher order then addition and 

691
00:46:00,000 --> 00:46:04,000
subtraction. And we can use parenthesis to override 

692
00:46:04,000 --> 00:46:08,000
the default order. We have the same concept in logical operator 

693
00:46:08,000 --> 00:46:12,000
So the and operator is always evaluated first. 

694
00:46:12,000 --> 00:46:16,000
So when this query is executed, the query execution engine 

695
00:46:16,000 --> 00:46:20,000
first evaluates this condition, because here we're using an and

696
00:46:20,000 --> 00:46:24,000
it doesn't matter that we typed out this condition after the first condition. 

697
00:46:24,000 --> 00:46:28,000
Because the and operator has a higher precedence. Now you can always

698
00:46:28,000 --> 00:46:32,000
change the order using parenthesis. And this also makes your code cleaner 

699
00:46:32,000 --> 00:46:36,000
and easier to understand. So here we can put parenthesis, 

700
00:46:36,000 --> 00:46:40,000
around these last two conditions, 

701
00:46:40,000 --> 00:46:44,000
and also we can put these in a  new line for 

702
00:46:44,000 --> 00:46:48,000
clarity. Something like this. So anyone 

703
00:46:48,000 --> 00:46:52,000
who reads this code can easily understand what is the intent of this query. 

704
00:46:52,000 --> 00:46:56,000
Now we also have logical operator called 

705
00:46:56,000 --> 00:47:00,000
not. And we use that to negate a condition. So, 

706
00:47:00,000 --> 00:47:04,000
I'm going to simplify our where clause. Let's say

707
00:47:04,000 --> 00:47:08,000
we're searching for customers who were born after 1990 or 

708
00:47:08,000 --> 00:47:12,000
we have more then 1000 points. If we execute this query 

709
00:47:12,000 --> 00:47:16,000
we get these people. Customers with 

710
00:47:16,000 --> 00:47:20,000
ID 1, 3, 5 and so on. Now we can use the not operator 

711
00:47:20,000 --> 00:47:24,000
to negate this condition. So we apply not here, and 

712
00:47:24,000 --> 00:47:28,000
preferably we also put parenthesis around this condition. 

713
00:47:28,000 --> 00:47:32,000
Now when we execute this query, we see other customers that are not 

714
00:47:32,000 --> 00:47:36,000
in the current results set. Let's take a look. So, 

715
00:47:36,000 --> 00:47:40,000
instead of customers with id's 1356

716
00:47:40,000 --> 00:47:44,000
and so on, we get customers with id's 2 4 and 10. 

717
00:47:44,000 --> 00:47:48,000
Now technically these customers were born before 1990.

718
00:47:48,000 --> 00:47:52,000
And we have less then 1000 points. So if you look here, 

719
00:47:52,000 --> 00:47:56,000
this first customer was born before 1990 and 

720
00:47:56,000 --> 00:48:00,000
he has less then 1000 points. How do they know that? Let me show

721
00:48:00,000 --> 00:48:04,000
you a trick that I learned in math. Whenever you have a not 

722
00:48:04,000 --> 00:48:08,000
operator. You can simplify your expression like this. We apply the not operator 

723
00:48:08,000 --> 00:48:12,000
to the first condition. People who were born after

724
00:48:12,000 --> 00:48:16,000
1990, how can we negate this condition? Well, 

725
00:48:16,000 --> 00:48:20,000
the greater than operator becomes less then or equal to. 

726
00:48:20,000 --> 00:48:24,000
That is the inverse of that condition. Now we 

727
00:48:24,000 --> 00:48:28,000
apply the not to or to negate the or. What do we get?

728
00:48:28,000 --> 00:48:32,000
We get and. Finally apply

729
00:48:32,000 --> 00:48:36,000
the not operator on the last condition. We both have more then 1000 points. 

730
00:48:36,000 --> 00:48:40,000
When we negate this condition we get customers with less then or equal 

731
00:48:40,000 --> 00:48:44,000
to 1000 points. Now, you can remove the not operator 

732
00:48:44,000 --> 00:48:48,000
to simplify this, we don't need parenthesis anymore because we 

733
00:48:48,000 --> 00:48:52,000
only have 2 conditions that are combined with an end. Here is the result. 

734
00:48:52,000 --> 00:48:56,000
As you can see, this is much easier to read and understand 

735
00:48:56,000 --> 00:49:00,000
people who were born before this day and they have less then 1000 points 

736
00:49:00,000 --> 00:49:04,000


737
00:49:04,000 --> 00:49:08,000
Alright, here's your exercise. From the order items 

738
00:49:08,000 --> 00:49:12,000
table, get the items for order number 6, 

739
00:49:12,000 --> 00:49:16,000
where the total price for the total item is greater then 

740
00:49:16,000 --> 00:49:20,000
30. 

741
00:49:20,000 --> 00:49:24,000
Alright, here's the order items table, in

742
00:49:24,000 --> 00:49:28,000
this table we have these columns order id, product id, quality, and unit 

743
00:49:28,000 --> 00:49:32,000
price. If we multiply the quantity by unit price we can 

744
00:49:32,000 --> 00:49:36,000
get the total cost of that item. And then we can compare it with 

745
00:49:36,000 --> 00:49:40,000
30. So, let's go ahead and write this query. 

746
00:49:40,000 --> 00:49:44,000
Select star 

747
00:49:44,000 --> 00:49:48,000
from order items. Where 

748
00:49:48,000 --> 00:49:52,000
here we need two conditions one is for order, so order 

749
00:49:52,000 --> 00:49:56,000
_id should be 6, and the second condition 

750
00:49:56,000 --> 00:50:00,000
we want to calculate the total price. So we get the unit price

751
00:50:00,000 --> 00:50:04,000
multiply it by quantity and this 

752
00:50:04,000 --> 00:50:08,000
value should be greater than 30. So as you can see, 

753
00:50:08,000 --> 00:50:12,000
we can use an arithmetic expression in the where clause. It's not limited 

754
00:50:12,000 --> 00:50:16,000
to the select clause. Okay? Now let's execute this query and see

755
00:50:16,000 --> 00:50:20,000
what we get. We should get only 1 item, 

756
00:50:20,000 --> 00:50:24,000
that is for product 1, here in quantities 4 and unit price 

757
00:50:24,000 --> 00:50:28,000
is just over 8 dollars, so the total price for this item, is greater than 30. 

758
00:50:28,000 --> 00:50:32,000
Hey guys, Mosh here. 

759
00:50:32,000 --> 00:50:36,000
In case you haven't seen my website yet, head over to codewithmosh.com. 

760
00:50:36,000 --> 00:50:40,000
This is my coding school where you can find plenty of courses 

761
00:50:40,000 --> 00:50:44,000
on web and mobile application development. In fact recently I 

762
00:50:44,000 --> 00:50:48,000
published a complete SQL course that is about 10 hours long, 

763
00:50:48,000 --> 00:50:52,000
and it teaches you everything you need to know from the basic to advanced topics 

764
00:50:52,000 --> 00:50:56,000
such as database design, security, writing complex queries, 

765
00:50:56,000 --> 00:51:00,000
transactions, events, and much much more. These are the

766
00:51:00,000 --> 00:51:04,000
topics that every software engineer must master. This YouTube course 

767
00:51:04,000 --> 00:51:08,000
you're watching, is the first 3 hours of my complete SQL

768
00:51:08,000 --> 00:51:12,000
course that is about 10 hours long. So if you want to master SQL

769
00:51:12,000 --> 00:51:16,000
and get job ready, I highly encourage you to enroll in my 

770
00:51:16,000 --> 00:51:20,000
complete SQL course. You can watch it anytime, anywhere, as many times as you

771
00:51:20,000 --> 00:51:24,000
want, you can watch it online or download the videos. The course comes 

772
00:51:24,000 --> 00:51:28,000
with a 30 day money back guarantee, and a certificate of completion 

773
00:51:28,000 --> 00:51:32,000
that you can add to your resume. The price for this course is $149

774
00:51:32,000 --> 00:51:36,000
dollars, but the first 200 students can get it for just over 

775
00:51:36,000 --> 00:51:40,000
10 dollars. So if you're interested the link is below this video. 

776
00:51:40,000 --> 00:51:44,000


777
00:51:44,000 --> 00:51:48,000
In this tutorial I'm going to show you how to use the 

778
00:51:48,000 --> 00:51:52,000
in operator in SQL. So, as an example, let's say

779
00:51:52,000 --> 00:51:56,000
you want to get the customers that are in Virginia or

780
00:51:56,000 --> 00:52:00,000
Florida, or Georgia. One way to write this query is like this.

781
00:52:00,000 --> 00:52:04,000
So, where state equals Virginia, or 

782
00:52:04,000 --> 00:52:08,000
a state equals Georgia, or a state equals

783
00:52:08,000 --> 00:52:12,000
Florida. Now people who are new to the SQL language or 

784
00:52:12,000 --> 00:52:16,000
programming in general find this expression a little bit strange. 

785
00:52:16,000 --> 00:52:20,000
They ask, "Mosh, why can't we write this expression like this?"

786
00:52:20,000 --> 00:52:24,000
where state equals Virginia or Georgia or 

787
00:52:24,000 --> 00:52:28,000
Florida. Here's the reason, we use the or operator 

788
00:52:28,000 --> 00:52:32,000
to combine multiple conditions. So here we have a condition 

789
00:52:32,000 --> 00:52:36,000
or an expression more accurately, but on the right side of this or operator 

790
00:52:36,000 --> 00:52:40,000
we have a string. In SQL we cannot combine a string 

791
00:52:40,000 --> 00:52:44,000
with a boolean expression that expresses a boolean value which can be 

792
00:52:44,000 --> 00:52:48,000
true or false. So that is why we have to write our query 

793
00:52:48,000 --> 00:52:52,000
like this. So we have multiple expressions or multiple conditions 

794
00:52:52,000 --> 00:52:56,000
and we're combining them using the or operator. 

795
00:52:56,000 --> 00:53:00,000
So, now if we execute this query we get these customers here. 

796
00:53:00,000 --> 00:53:04,000
customers here but there is a shorter and cleaner way to get the same result. 

797
00:53:04,000 --> 00:53:08,000
Instead of combining multiple conditions using the or operator we can

798
00:53:08,000 --> 00:53:12,000
use the in operator. So, where state 

799
00:53:12,000 --> 00:53:16,000
is in and then in parenthesis we add all the values, 

800
00:53:16,000 --> 00:53:20,000
like Virginia, comma, Florida, comma

801
00:53:20,000 --> 00:53:24,000
Georgia and the order doesn't matter, this query is exactly equivalent 

802
00:53:24,000 --> 00:53:28,000
to what we had earlier, but a you can see it's shorter and easier to understand. 

803
00:53:28,000 --> 00:53:32,000
So, let's execute it, look, we get the exact same result.

804
00:53:32,000 --> 00:53:36,000
Now here we can also use the not operator. Let's say you want to get the

805
00:53:36,000 --> 00:53:40,000
customer's outside of these states, so we can use 

806
00:53:40,000 --> 00:53:44,000
rare state, not in this list. 

807
00:53:44,000 --> 00:53:48,000
Now if you execute this query, we get customers who are located in Colorado, 

808
00:53:48,000 --> 00:53:52,000
Texas and so on. So use the in operator whenever 

809
00:53:52,000 --> 00:53:56,000
you want to compare an attribute to a list of values. 

810
00:53:56,000 --> 00:54:00,000
Now here is your 

811
00:54:00,000 --> 00:54:04,000
exercise. I want you to write a query to get the products where 

812
00:54:04,000 --> 00:54:08,000
their quantity in stock equals on of these values. 

813
00:54:08,000 --> 00:54:12,000
49, 38, and 72, so pause the video, do this exercise, and 

814
00:54:12,000 --> 00:54:16,000
then come back and continue watching. 

815
00:54:16,000 --> 00:54:20,000
Alright, this is pretty easy, so we do a 

816
00:54:20,000 --> 00:54:24,000
select star to get all the columns from the products table, 

817
00:54:24,000 --> 00:54:28,000
where quantity in stock 

818
00:54:28,000 --> 00:54:32,000
in we use the in operator to compare this attribute with these values. 

819
00:54:32,000 --> 00:54:36,000
49, 38, and 72, let's execute the query, 

820
00:54:36,000 --> 00:54:40,000
we get only 2 records because we 

821
00:54:40,000 --> 00:54:44,000
don't have a product with quantity in stock equal to 72. 

822
00:54:44,000 --> 00:54:48,000


823
00:54:48,000 --> 00:54:52,000
In this tutorial, we're going to look at the between operator 

824
00:54:52,000 --> 00:54:56,000
in SQL, so that means we want to get the customers who have more

825
00:54:56,000 --> 00:55:00,000
then 1000 and less then 3000 points. What made you

826
00:55:00,000 --> 00:55:04,000
write these queries like this? Where, points, greater than

827
00:55:04,000 --> 00:55:08,000
thousand, more accurately greater than or equal to 1000. 

828
00:55:08,000 --> 00:55:12,000
And, points less then or equal to 

829
00:55:12,000 --> 00:55:16,000
3000. When we execute this query we get 

830
00:55:16,000 --> 00:55:20,000
how many, we get 4 people that satisfy my criteria. 

831
00:55:20,000 --> 00:55:24,000
Now whenever you're comparing an attribute with a range of values, 

832
00:55:24,000 --> 00:55:28,000
you can use the between operator, and that makes your code shorter and cleaner. 

833
00:55:28,000 --> 00:55:32,000
So, we can rewrite this expression like this, where points, 

834
00:55:32,000 --> 00:55:36,000
between 1000 and 3000. 

835
00:55:36,000 --> 00:55:40,000
This is exactly equivalent to what we had before, so these

836
00:55:40,000 --> 00:55:44,000
range values are also inclusive, so that means points is going to be 

837
00:55:44,000 --> 00:55:48,000
greater than or equal to 1000 or greater than or equal to 

838
00:55:48,000 --> 00:55:52,000
3000. Let's execute the query, we get the exact same result. 

839
00:55:52,000 --> 00:55:56,000


840
00:55:56,000 --> 00:56:00,000
Alright, now as an exercise, I want you to write a query, to get the customers 

841
00:56:00,000 --> 00:56:04,000
that are born between January 1st 1990 and January 

842
00:56:04,000 --> 00:56:08,000
21st, 2000. 

843
00:56:08,000 --> 00:56:12,000
Alright, so we start the 

844
00:56:12,000 --> 00:56:16,000
select star from customers, 

845
00:56:16,000 --> 00:56:20,000
where birth_date between 

846
00:56:20,000 --> 00:56:24,000
so what matters here is we can use the between operator 

847
00:56:24,000 --> 00:56:28,000
as well. It's not limited to using numbers. So with birth date between

848
00:56:28,000 --> 00:56:32,000
now we need to supply two date values, so as I told you before, 

849
00:56:32,000 --> 00:56:36,000
the format for dates is four digits for the year, so 

850
00:56:36,000 --> 00:56:40,000
1990, two digits for the month, and two digits for the date. 

851
00:56:40,000 --> 00:56:44,000
So, the birthdate should be between this value and 

852
00:56:44,000 --> 00:56:48,000
here's a second value. 2000, 0, 1, and 

853
00:56:48,000 --> 00:56:52,000
01. Let's execute this query, we get 

854
00:56:52,000 --> 00:56:56,000
only 3 people who match this criteria. 

855
00:56:56,000 --> 00:57:00,000


856
00:57:00,000 --> 00:57:04,000
In this tutorial, I'm going to show you how to retrieve 

857
00:57:04,000 --> 00:57:08,000
rows that match a specific string pattern, for example, 

858
00:57:08,000 --> 00:57:12,000
let's say we only want to get to customers who's last name start with 

859
00:57:12,000 --> 00:57:16,000
3. So, here in the where clause we type out

860
00:57:16,000 --> 00:57:20,000
where last name this is where we use the like operator, 

861
00:57:20,000 --> 00:57:24,000
and right after that we have a string pattern, so, 

862
00:57:24,000 --> 00:57:28,000
you want to get the customers who's last name start with b and we have 

863
00:57:28,000 --> 00:57:32,000
any number of characters after b. So use the 

864
00:57:32,000 --> 00:57:36,000
percent sign to indicate any number of characters, you may have 

865
00:57:36,000 --> 00:57:40,000
one character after b or no characters or 10 characters, with this

866
00:57:40,000 --> 00:57:44,000
pattern, you get all the customers who's patterns start with b. 

867
00:57:44,000 --> 00:57:48,000
And also it doesn't matter if it's an upper case or lower case b. 

868
00:57:48,000 --> 00:57:52,000
So, let's execute this query, there you go, so you only have 

869
00:57:52,000 --> 00:57:56,000
3 customers who's last name starts with b. As another 

870
00:57:56,000 --> 00:58:00,000
example, let's say we only want to get the customers who's last name starts with 

871
00:58:00,000 --> 00:58:04,000
brush. So, we change our pattern to brush, 

872
00:58:04,000 --> 00:58:08,000
percent. Now, let's execute the query, we only get 

873
00:58:08,000 --> 00:58:12,000
this one customer here. Now this percent sign doesn't have to be 

874
00:58:12,000 --> 00:58:16,000
at the end of the pattern, it can be anywhere. For example, let's say we want 

875
00:58:16,000 --> 00:58:20,000
to search for customers who have an e in their last name, whether it's at the beginning 

876
00:58:20,000 --> 00:58:24,000
in the middle or at the end, so we change our pattern to 

877
00:58:24,000 --> 00:58:28,000
percent e percent this pattern means we can 

878
00:58:28,000 --> 00:58:32,000
have any number of characters before or after b. Let's

879
00:58:32,000 --> 00:58:36,000
execute the query, these are the customers that have a b 

880
00:58:36,000 --> 00:58:40,000
somewhere in their last name. It doesn't matter if b is in the beginning 

881
00:58:40,000 --> 00:58:44,000
or in the middle or at the end. Let's look at another example, 

882
00:58:44,000 --> 00:58:48,000
I want to get all the customers who's last names end 

883
00:58:48,000 --> 00:58:52,000
with y, so here's the pattern we use, 

884
00:58:52,000 --> 00:58:56,000
let's execute this query, so we have 5 customers 

885
00:58:56,000 --> 00:59:00,000
who's last name ends with a y. So this is how we use the 

886
00:59:00,000 --> 00:59:04,000
percent sign. Now we also have an underscore and 

887
00:59:04,000 --> 00:59:08,000
that matches a single character so with this pattern you get customer 

888
00:59:08,000 --> 00:59:12,000
who's last name is exactly two characters long, 

889
00:59:12,000 --> 00:59:16,000
we don't care what the first character is, but the second character should be y. 

890
00:59:16,000 --> 00:59:20,000
Let's execute his for you. Obviously we don't have any customers who's last 

891
00:59:20,000 --> 00:59:24,000
name matches this pattern. But if you change this pattern to 

892
00:59:24,000 --> 00:59:28,000
5 under score, so 1234

893
00:59:28,000 --> 00:59:32,000
5, followed by a y we should get 

894
00:59:32,000 --> 00:59:36,000
these customers. So their last name is exactly 

895
00:59:36,000 --> 00:59:40,000
6 characters, we don't care about the first 5 characters, but all

896
00:59:40,000 --> 00:59:44,000
of them end with a y. Now, as another example, 

897
00:59:44,000 --> 00:59:48,000
we can replace the first underscore with b, and that means 

898
00:59:48,000 --> 00:59:52,000
we want to get the customers who's last names start with b, and 

899
00:59:52,000 --> 00:59:56,000
after b we have exactly 4 characters followed by a 

900
00:59:56,000 --> 01:00:00,000
y. Let's execute this query. So we only have one customer, 

901
01:00:00,000 --> 01:00:04,000
that matches this pattern. So this is how we use the 

902
01:00:04,000 --> 01:00:08,000
light operator, use the percent sign to represent 

903
01:00:08,000 --> 01:00:12,000
any number of characters and an underscore 

904
01:00:12,000 --> 01:00:16,000
to represent a single character. 

905
01:00:16,000 --> 01:00:20,000
Now this like operator in MySQL is an older operator 

906
01:00:20,000 --> 01:00:24,000
but we also have a newer one that is more powerful and it allows us to search for

907
01:00:24,000 --> 01:00:28,000
any string patterns. And that's what I'm going to show you next. 

908
01:00:28,000 --> 01:00:32,000
Alright. 

909
01:00:32,000 --> 01:00:36,000
Here I'm going to give you two exercises for the like operator. 

910
01:00:36,000 --> 01:00:40,000
First, I want you to get the customers who's addresses contain trade

911
01:00:40,000 --> 01:00:44,000
or avenue, and next I want you to get the customers who's phone 

912
01:00:44,000 --> 01:00:48,000
numbers end with 9. 

913
01:00:48,000 --> 01:00:52,000


914
01:00:52,000 --> 01:00:56,000
Alright, let's get started with the first exercise. So 

915
01:00:56,000 --> 01:01:00,000
start from customers where address

916
01:01:00,000 --> 01:01:04,000
like now here we want to use a search pattern like this. 

917
01:01:04,000 --> 01:01:08,000
You want to have tray (?) but tray can be anywhere in the address. So, 

918
01:01:08,000 --> 01:01:12,000
we put a percent before and after tray. 

919
01:01:12,000 --> 01:01:16,000
Next, we should use the or operator to search for another pattern. 

920
01:01:16,000 --> 01:01:20,000
Or address like, let me 

921
01:01:20,000 --> 01:01:24,000
put this on a new line that is better, address

922
01:01:24,000 --> 01:01:28,000
once again, percent, avenue percent, that's it. 

923
01:01:28,000 --> 01:01:32,000
So, let's execute this query, 

924
01:01:32,000 --> 01:01:36,000
here is the result, you should get the customers with ID's 

925
01:01:36,000 --> 01:01:40,000
2, 9, and 10. If you look at their addresses, all of them

926
01:01:40,000 --> 01:01:44,000
have either tray or avenue in their

927
01:01:44,000 --> 01:01:48,000
address. Now let's work on the second exercise, you want to get 

928
01:01:48,000 --> 01:01:52,000
the customers who's phone numbers end with 9. That is pretty easy, 

929
01:01:52,000 --> 01:01:56,000
so, let me change our where clause. Where 

930
01:01:56,000 --> 01:02:00,000
phone once again we use the like operator and a percent, 

931
01:02:00,000 --> 01:02:04,000
followed by a 9. That's all you have to do. Let's execute the 

932
01:02:04,000 --> 01:02:08,000
query. So, here's the result, customers with 

933
01:02:08,000 --> 01:02:12,000
id's 3 and 7, their phone numbers, and 

934
01:02:12,000 --> 01:02:16,000
9. So this is how we use the like operator. And by the way

935
01:02:16,000 --> 01:02:20,000
you can always use the not operator here let's say you want to get the 

936
01:02:20,000 --> 01:02:24,000
customers who's phone numbers don't end with 9, 

937
01:02:24,000 --> 01:02:28,000
so we simply prefix like with not. Now, 

938
01:02:28,000 --> 01:02:32,000
if we execute this query one more time, we get all the other 

939
01:02:32,000 --> 01:02:36,000
customers in the database. 

940
01:02:36,000 --> 01:02:40,000
In the last tutorial you

941
01:02:40,000 --> 01:02:44,000
learned about the like operator in SQL. So as another example 

942
01:02:44,000 --> 01:02:48,000
let's say you want to search for the customers who have the word 

943
01:02:48,000 --> 01:02:52,000
field in their last name. So we type out the where clause like this, 

944
01:02:52,000 --> 01:02:56,000
where last name, like, percent, 

945
01:02:56,000 --> 01:03:00,000
field, percent, so the word field, 

946
01:03:00,000 --> 01:03:04,000
can be anywhere in the last name. Let's execute this query, we get 

947
01:03:04,000 --> 01:03:08,000
only one customer, beautiful. Now we also have another

948
01:03:08,000 --> 01:03:12,000
operator in MySQL, that is reg x which is 

949
01:03:12,000 --> 01:03:16,000
short for regular expression, and regular expressions are extremely 

950
01:03:16,000 --> 01:03:20,000
powerful when it comes to searching for strings. So they allow us to

951
01:03:20,000 --> 01:03:24,000
search for more complex patterns. Here's an example. If I want to

952
01:03:24,000 --> 01:03:28,000
rewrite this last where clause using a regular 

953
01:03:28,000 --> 01:03:32,000
expression it looks like. Where last name 

954
01:03:32,000 --> 01:03:36,000
ragexp now here in our string pattern 

955
01:03:36,000 --> 01:03:40,000
we don't have to type out the person's size we only type 

956
01:03:40,000 --> 01:03:44,000
out field so what we have on line 4 is exactly 

957
01:03:44,000 --> 01:03:48,000
identical to what we have on line 3, let's execute this query 

958
01:03:48,000 --> 01:03:52,000
we get the same result, beautiful, now here in regular 

959
01:03:52,000 --> 01:03:56,000
expressions, we have additional characters that we don't have when we use the 

960
01:03:56,000 --> 01:04:00,000
like operator. For example, we can use the carrot sign to indicate

961
01:04:00,000 --> 01:04:04,000
the beginning of a string. So if I put a carrot 

962
01:04:04,000 --> 01:04:08,000
just before the word field, that means our 

963
01:04:08,000 --> 01:04:12,000
last name must start with field. Obviously, if you execute

964
01:04:12,000 --> 01:04:16,000
this query, we don't get anyone that matches this criteria, so we use the 

965
01:04:16,000 --> 01:04:20,000
carrot sign to represent the beginning of a string. We 

966
01:04:20,000 --> 01:04:24,000
also have a dollar sign to represent the end of a string. 

967
01:04:24,000 --> 01:04:28,000
So this pattern means the last name must end with field. 

968
01:04:28,000 --> 01:04:32,000
Let's execute this query, you get the same result as before. Now

969
01:04:32,000 --> 01:04:36,000
we can also search for multiple words here, for example let' say we want to find 

970
01:04:36,000 --> 01:04:40,000
the customers who have the word field or mac in their last name

971
01:04:40,000 --> 01:04:44,000
So, we use a pipe, a vertical bar, 

972
01:04:44,000 --> 01:04:48,000
and type out another pattern. Let's execute

973
01:04:48,000 --> 01:04:52,000
this query, so here we have two customers, one of them has the word 

974
01:04:52,000 --> 01:04:56,000
mac, the other has the word field and the last name. 

975
01:04:56,000 --> 01:05:00,000
Now we can take this to the next level. Let's say we want  to find the customers who

976
01:05:00,000 --> 01:05:04,000
have the words field, or Mac, or rows 

977
01:05:04,000 --> 01:05:08,000
in their last name. Let's execute the query we get 3 customers. 

978
01:05:08,000 --> 01:05:12,000
Beautiful. So we use a pipe or a vertical board 

979
01:05:12,000 --> 01:05:16,000
to represent multiple search patterns. Now as another example, 

980
01:05:16,000 --> 01:05:20,000
we can change our first search pattern to something like this.

981
01:05:20,000 --> 01:05:24,000
Now this pattern means this last name should either start 

982
01:05:24,000 --> 01:05:28,000
with the word field, or it should have the word

983
01:05:28,000 --> 01:05:32,000
mac in it or it should have the word rows. Let'sexecute

984
01:05:32,000 --> 01:05:36,000
the query, now we get only two customers, because our customer

985
01:05:36,000 --> 01:05:40,000
with the last name brush field doesn't match this pattern. 

986
01:05:40,000 --> 01:05:44,000
However, if we change our first pattern to field 

987
01:05:44,000 --> 01:05:48,000
$ and execute the query we get 3 people here, 

988
01:05:48,000 --> 01:05:52,000
3 customers. So this is how we can combine multiple special characters

989
01:05:52,000 --> 01:05:56,000
when building a complex pattern. Now let's look at another 

990
01:05:56,000 --> 01:06:00,000
example, let's say you want to search for customers who have an e in their last name. 

991
01:06:00,000 --> 01:06:04,000
So these are all the people, alright, now let's say 

992
01:06:04,000 --> 01:06:08,000
you want to make sure that before the letter e, we should either have a 

993
01:06:08,000 --> 01:06:12,000
g or an i. So this is where we use square brackets. 

994
01:06:12,000 --> 01:06:16,000
And inside the brackets we add multiple characters like

995
01:06:16,000 --> 01:06:20,000
g, i, m and that matches any customers who have 

996
01:06:20,000 --> 01:06:24,000
ge or ie or me 

997
01:06:24,000 --> 01:06:28,000
in their last name. So any of these characters can come before e. 

998
01:06:28,000 --> 01:06:32,000
Now, let's execute this query, 

999
01:06:32,000 --> 01:06:36,000
there you go, we only get 2 customers, and the first

1000
01:06:36,000 --> 01:06:40,000
example before e we have i which is one of the characters 

1001
01:06:40,000 --> 01:06:44,000
inside the brackets, in the second example, before e we have 

1002
01:06:44,000 --> 01:06:48,000
a g which is also another valid character before 

1003
01:06:48,000 --> 01:06:52,000
and once again the square brackets don't have to be before

1004
01:06:52,000 --> 01:06:56,000
we could add them after e, any customers who have e 

1005
01:06:56,000 --> 01:07:00,000
followed by an f or an m or a q in their last 

1006
01:07:00,000 --> 01:07:04,000
name, can be returned with this pattern, 

1007
01:07:04,000 --> 01:07:08,000
if we don't have anyone in the database so this is how we use square brackets, 

1008
01:07:08,000 --> 01:07:12,000
now we can also supply a range of characters, for example 

1009
01:07:12,000 --> 01:07:16,000
we can have e and just before e you can have 

1010
01:07:16,000 --> 01:07:20,000
as many characters from a to h, you don't have to

1011
01:07:20,000 --> 01:07:24,000
type them out explicitly like abcdefg, that's very 

1012
01:07:24,000 --> 01:07:28,000
verbose, so, we can type out a to h. 

1013
01:07:28,000 --> 01:07:32,000
And then if we execute this query we get these three people. 

1014
01:07:32,000 --> 01:07:36,000
So, let's quickly recap everything you learned about regular expressions

1015
01:07:36,000 --> 01:07:40,000
in this tutorial. Use a carrot to represent the beginning of

1016
01:07:40,000 --> 01:07:44,000
a string, so beginning, we use a dollar sign to represent 

1017
01:07:44,000 --> 01:07:48,000
the end of a string, we use a vertical bar or pipe, 

1018
01:07:48,000 --> 01:07:52,000
to represent a logical or so we can supply multiple

1019
01:07:52,000 --> 01:07:56,000
search patterns, we use square brackets to 

1020
01:07:56,000 --> 01:08:00,000
match any single characters listed in the brackets, and finally 

1021
01:08:00,000 --> 01:08:04,000
we use square brackets with a  hyphen to represent a range. 

1022
01:08:04,000 --> 01:08:08,000
So any characters from a to f. 

1023
01:08:08,000 --> 01:08:12,000
Technically MySQL supports more special characters but quite

1024
01:08:12,000 --> 01:08:16,000
honestly, the ones that I've listed in this tutorial are the ones that you'll be using 90% of the

1025
01:08:16,000 --> 01:08:20,000
time. So just memorize these and you're good to go.

1026
01:08:20,000 --> 01:08:24,000


1027
01:08:24,000 --> 01:08:28,000
With honesty a lot of beginners find the syntax for regular

1028
01:08:28,000 --> 01:08:32,000
expressions confusing, so in this video I'm going to give you 4 exercises that I have carefully 

1029
01:08:32,000 --> 01:08:36,000
designed to help you quickly learn about this syntax. Here's

1030
01:08:36,000 --> 01:08:40,000
the first exercise, get the customer's who's first names are Elka 

1031
01:08:40,000 --> 01:08:44,000
or Ambur. And note that this is Ambur with a U. 

1032
01:08:44,000 --> 01:08:48,000
Now for the second episode return the customer's who's names 

1033
01:08:48,000 --> 01:08:52,000
end with ei or on. 

1034
01:08:52,000 --> 01:08:56,000
Here's the third exercise get the customer's who's last names start with

1035
01:08:56,000 --> 01:09:00,000
my or it contains se, and finally 

1036
01:09:00,000 --> 01:09:04,000
as the last exercise return the customer's who's last names

1037
01:09:04,000 --> 01:09:08,000
contain e followed by r or a u. 

1038
01:09:08,000 --> 01:09:12,000
So, go ahead and spend 2-3 minutes on this exercise, 

1039
01:09:12,000 --> 01:09:16,000
when you're done come back and continue watching. 

1040
01:09:16,000 --> 01:09:20,000


1041
01:09:20,000 --> 01:09:24,000
Alright, let's knock out the first exercise. So we'll get 

1042
01:09:24,000 --> 01:09:28,000
allows, there's a c here, so let's start from 

1043
01:09:28,000 --> 01:09:32,000


1044
01:09:32,000 --> 01:09:36,000
regular expression, and here's our pattern, you're going to search 

1045
01:09:36,000 --> 01:09:40,000
for two words either Elka or Ambur. 

1046
01:09:40,000 --> 01:09:44,000
As simple as that. Let's execute this query, we should get two

1047
01:09:44,000 --> 01:09:48,000
customers, there you go, Ambur and Elka. Alright.

1048
01:09:48,000 --> 01:09:52,000
Now, let's knock out the second exercise. So I'm going to delete these 

1049
01:09:52,000 --> 01:09:56,000
we don't need them anymore. So we want to get the customers 

1050
01:09:56,000 --> 01:10:00,000
select start from customers, where 

1051
01:10:00,000 --> 01:10:04,000
last name should end with either ey or 

1052
01:10:04,000 --> 01:10:08,000
om. So, in the search pattern we type out 

1053
01:10:08,000 --> 01:10:12,000
ey followed by a dollar sign to indicate the end of a string

1054
01:10:12,000 --> 01:10:16,000
then we add a vertical bar to supply the second

1055
01:10:16,000 --> 01:10:20,000
search pattern. So On and once again dollar sign. 

1056
01:10:20,000 --> 01:10:24,000
Let's execute this query, oops I forgot to type out

1057
01:10:24,000 --> 01:10:28,000
regular expression, there you go. So, 

1058
01:10:28,000 --> 01:10:32,000
Let's execute this query, and you should get 

1059
01:10:32,000 --> 01:10:36,000
these four customers with ID's one 

1060
01:10:36,000 --> 01:10:40,000
three, five and seven. The first three, five, and seven, the first three, their last names 

1061
01:10:40,000 --> 01:10:44,000
end with ey, and the last customer, his or her last 

1062
01:10:44,000 --> 01:10:48,000
name ends with on. Alright, Now, let's 

1063
01:10:48,000 --> 01:10:52,000
work on the third exercise. So I'm just going to change the regular expression 

1064
01:10:52,000 --> 01:10:56,000
here, we want to get the customers whose last names start with

1065
01:10:56,000 --> 01:11:00,000
my or contains se. So we use 

1066
01:11:00,000 --> 01:11:04,000
a carrot to indicate the beginning of a string so 

1067
01:11:04,000 --> 01:11:08,000
it should start with my, or it should contain se, 

1068
01:11:08,000 --> 01:11:12,000
again, very easy, let's execute this query 

1069
01:11:12,000 --> 01:11:16,000
and we get the customer's with ID's 

1070
01:11:16,000 --> 01:11:20,000
4, 8, and 10 and finally 

1071
01:11:20,000 --> 01:11:24,000
we want to get the customers who's last names contain e 

1072
01:11:24,000 --> 01:11:28,000
so, let's change the search pattern, we should have a b, 

1073
01:11:28,000 --> 01:11:32,000
followed by r or u. Now there are two ways to write 

1074
01:11:32,000 --> 01:11:36,000
this regular expression, we can use square brackets so 

1075
01:11:36,000 --> 01:11:40,000
we have b followed by r or u, that's one way, or

1076
01:11:40,000 --> 01:11:44,000
the other way is to use a vertical bar. So b

1077
01:11:44,000 --> 01:11:48,000
r or bu. These are both valid solutions.

1078
01:11:48,000 --> 01:11:52,000
So, I hope you knocked out these exercises, in the next tutorial I'm going to show you 

1079
01:11:52,000 --> 01:11:56,000
how to get the records with missing values. 

1080
01:11:56,000 --> 01:12:00,000


1081
01:12:00,000 --> 01:12:04,000
In this tutorial, I'm going to show you how to look for records that miss 

1082
01:12:04,000 --> 01:12:08,000
an attribute. For example, if you select all the customers in our database, 

1083
01:12:08,000 --> 01:12:12,000
you can see that the customer with id 5 doesn't have 

1084
01:12:12,000 --> 01:12:16,000
a full number. So if you look closely here, you can see the value of

1085
01:12:16,000 --> 01:12:20,000
null. Null means the absence of a value. Now let's say

1086
01:12:20,000 --> 01:12:24,000
we want to search for all the customers who don't have a phone. Perhaps you want to send them an email

1087
01:12:24,000 --> 01:12:28,000
and say hey, your phone is missing in our system. So how can

1088
01:12:28,000 --> 01:12:32,000
we get these customers? That is very easy? We use the is null

1089
01:12:32,000 --> 01:12:36,000
operator, so in the where clause, we type out 

1090
01:12:36,000 --> 01:12:40,000
where phone is null. Now let's execute 

1091
01:12:40,000 --> 01:12:44,000
this query, we only get one customer who doesn't have a phone, 

1092
01:12:44,000 --> 01:12:48,000
now here we can also use the not operator to get 

1093
01:12:48,000 --> 01:12:52,000
the customers who do have a phone. So we change the conditions to

1094
01:12:52,000 --> 01:12:56,000
is not null. Let's execute the query, 

1095
01:12:56,000 --> 01:13:00,000
now in the query results, every customer 

1096
01:13:00,000 --> 01:13:04,000
does have a phone number. 

1097
01:13:04,000 --> 01:13:08,000
For this exercise, I want you to write a query 

1098
01:13:08,000 --> 01:13:12,000
to get the orders that are not shipped yet. This is a very useful query 

1099
01:13:12,000 --> 01:13:16,000
that is used in a  lot of real applications. For example, let's say you're an admin for

1100
01:13:16,000 --> 01:13:20,000
online shop. You want to see the orders that are not shipped yet, so you can see 

1101
01:13:20,000 --> 01:13:24,000
them all. So write a query, and get these orders. 

1102
01:13:24,000 --> 01:13:28,000


1103
01:13:28,000 --> 01:13:32,000
So here we have the orders table, let's have a quick look at the

1104
01:13:32,000 --> 01:13:36,000
data in this table. So if you pay close attention 

1105
01:13:36,000 --> 01:13:40,000
you see some of these orders don't have a

1106
01:13:40,000 --> 01:13:44,000
date. And these orders also don't have a shipper id which 

1107
01:13:44,000 --> 01:13:48,000
is a unique number for identifying the shippers. So any order

1108
01:13:48,000 --> 01:13:52,000
that misses the value for the ship date or shipper ID, 

1109
01:13:52,000 --> 01:13:56,000
is considered an order that is not shipped. So let's go ahead and write 

1110
01:13:56,000 --> 01:14:00,000
a query to get these orders. So back to our query editor 

1111
01:14:00,000 --> 01:14:04,000
select star from orders where 

1112
01:14:04,000 --> 01:14:08,000
ship_date is 

1113
01:14:08,000 --> 01:14:12,000
null. You could also write shipper id is null. They're both

1114
01:14:12,000 --> 01:14:16,000
equally correct. So let's execute this query, and you should get 

1115
01:14:16,000 --> 01:14:20,000
5 orders. Orders 1, 3, 4, 6, 

1116
01:14:20,000 --> 01:14:24,000
and 8. 

1117
01:14:24,000 --> 01:14:28,000
In this tutorial I'm going to

1118
01:14:28,000 --> 01:14:32,000
show you how to sort data in your sequel queries. So here in your

1119
01:14:32,000 --> 01:14:36,000
have a query to select all the customers from the customers table, if you look at 

1120
01:14:36,000 --> 01:14:40,000
the query result, you can see that our customer's or sorted by id, 

1121
01:14:40,000 --> 01:14:44,000
so we have customers 1, 2, 3, 4, and so on. This is the 

1122
01:14:44,000 --> 01:14:48,000
default sort column. But we can always change this using the 

1123
01:14:48,000 --> 01:14:52,000
order by clause. But first, let me explain 

1124
01:14:52,000 --> 01:14:56,000
why the customer id column is the default sort column. So first of all

1125
01:14:56,000 --> 01:15:00,000
the first I'm going to open up the navigators panel on the left side here's the customers

1126
01:15:00,000 --> 01:15:04,000
table, now let's click on this middle icon here that looks like 

1127
01:15:04,000 --> 01:15:08,000
tool. This opens up our customers table in the design mode, 

1128
01:15:08,000 --> 01:15:12,000
here we can change our columns we cana dd new column or 

1129
01:15:12,000 --> 01:15:16,000
remove existing ones or change that name and order and so on. 

1130
01:15:16,000 --> 01:15:20,000
Now if you pay close attention you can see a yellow key just before 

1131
01:15:20,000 --> 01:15:24,000
This means that this column is the primary key column. 

1132
01:15:24,000 --> 01:15:28,000
For this query. So in relational databases every

1133
01:15:28,000 --> 01:15:32,000
table should have a primary key column, and the values in that column 

1134
01:15:32,000 --> 01:15:36,000
should uniquely identify the records in that table. So 

1135
01:15:36,000 --> 01:15:40,000
back to our query window, you can see that the values in this column

1136
01:15:40,000 --> 01:15:44,000
 uniquely identify each customer, so the customer id column 

1137
01:15:44,000 --> 01:15:48,000
is the primary key column in this table, and that is why when you write a 

1138
01:15:48,000 --> 01:15:52,000
query against this table, our customers will sort it by id by default. 

1139
01:15:52,000 --> 01:15:56,000
Now, let me show you how to sort customers by a different column. 

1140
01:15:56,000 --> 01:16:00,000
So, here in the order by clause, you type out the name of another

1141
01:16:00,000 --> 01:16:04,000
column, like first name. Let's execute the query, now we can 

1142
01:16:04,000 --> 01:16:08,000
see our customers are no longer sorted by their id, instead 

1143
01:16:08,000 --> 01:16:12,000
they are sorted by their first name in ascending order. Now, 

1144
01:16:12,000 --> 01:16:16,000
if you want to reverse the sort order, simply type out de, 

1145
01:16:16,000 --> 01:16:20,000
e, sc, which is short for descending. Now, 

1146
01:16:20,000 --> 01:16:24,000
you're sorting the customers in this order, okay, 

1147
01:16:24,000 --> 01:16:28,000
we can also sort data by multiple columns, for example, 

1148
01:16:28,000 --> 01:16:32,000
let's say first we want to sort customers based on their state, 

1149
01:16:32,000 --> 01:16:36,000
and then within each state, we want to sort them by their first name. 

1150
01:16:36,000 --> 01:16:40,000
So, we type out multiple columns here, state 

1151
01:16:40,000 --> 01:16:44,000
and first name. Let's execute the query 

1152
01:16:44,000 --> 01:16:48,000
now, you can see that the first state we have here is california, followed 

1153
01:16:48,000 --> 01:16:52,000
by Colorado, and new here in Florida, you have two customers 

1154
01:16:52,000 --> 01:16:56,000
and these customers are sorted by their first name. Let's have a 

1155
01:16:56,000 --> 01:17:00,000
close look here, so first we have Ambur and then we have other

1156
01:17:00,000 --> 01:17:04,000
customers here. Now we can also use the descending argument anywhere here. 

1157
01:17:04,000 --> 01:17:08,000
For example, we can sort these customers by their state in descending 

1158
01:17:08,000 --> 01:17:12,000
order. And then sort them by their first name in ascending order 

1159
01:17:12,000 --> 01:17:16,000
or once, again in descending order. So there are various ways we can

1160
01:17:16,000 --> 01:17:20,000
sort data. Now one of the differences between MySQL, and 

1161
01:17:20,000 --> 01:17:24,000
other database management systems, is that in MySQL you can sort

1162
01:17:24,000 --> 01:17:28,000
data by any columns whether that column is in the select clause 

1163
01:17:28,000 --> 01:17:32,000
or not. For example, let's say you only want to select 

1164
01:17:32,000 --> 01:17:36,000
the first and last name for each customer. Now we can sort

1165
01:17:36,000 --> 01:17:40,000
the result by any columns in this table, they don't have to be first name and last names

1166
01:17:40,000 --> 01:17:44,000
For example, we can sort them by their birthdate, 

1167
01:17:44,000 --> 01:17:48,000
take a look, so this is a valid query in MySQL, but other databases

1168
01:17:48,000 --> 01:17:52,000
management sometimes yell at you when you update a query like this. 

1169
01:17:52,000 --> 01:17:56,000
Now we can also sort data by an alias for example, here in

1170
01:17:56,000 --> 01:18:00,000
out select clause let's add the number ten and give it a 

1171
01:18:00,000 --> 01:18:04,000
alias. As let's say points, so points is

1172
01:18:04,000 --> 01:18:08,000
not a valid column in this table, it's simply an alias 

1173
01:18:08,000 --> 01:18:12,000
or expression, in this case a simple number. And here we could have a complex 

1174
01:18:12,000 --> 01:18:16,000
mathematical expression, it doesn't really matter, we can still sort 

1175
01:18:16,000 --> 01:18:20,000
data by Alias, so we can order by points 

1176
01:18:20,000 --> 01:18:24,000
and then first name. Once again this is a valid, 

1177
01:18:24,000 --> 01:18:28,000
query from MySQL's point of view. Now one last thing before we finish 

1178
01:18:28,000 --> 01:18:32,000
this tutorial, I've seen some tutorials that teach you how to sort data by

1179
01:18:32,000 --> 01:18:36,000
calling positions, for example, here we can order it by 

1180
01:18:36,000 --> 01:18:40,000
1, 2, and that basically means sort the data by the first name, 

1181
01:18:40,000 --> 01:18:44,000
and then, the last name. So these are the orders of these columns, 

1182
01:18:44,000 --> 01:18:48,000
if you execute this query, you can see that our customers are sorted by their first 

1183
01:18:48,000 --> 01:18:52,000
name and then last name. Why this approach works, it's something that

1184
01:18:52,000 --> 01:18:56,000
you should avoid. Because if in the future you come back here and add 

1185
01:18:56,000 --> 01:19:00,000
a new column, in front of the first name column, let's say 

1186
01:19:00,000 --> 01:19:04,000
first, date. Now our customers are no longer sorted 

1187
01:19:04,000 --> 01:19:08,000
in this order. So sorting data by calling positions 

1188
01:19:08,000 --> 01:19:12,000
produces unexpected results and is something you should avoid. 

1189
01:19:12,000 --> 01:19:16,000
always sort by column names like first, 

1190
01:19:16,000 --> 01:19:20,000


1191
01:19:20,000 --> 01:19:24,000
Alright, here's your exercise for this tutorial. In this database, we have this table, 

1192
01:19:24,000 --> 01:19:28,000
called order items, where we find the items for each order. Now, 

1193
01:19:28,000 --> 01:19:32,000
I've written the query that you cannot see here, because that's the solution to the exercise 

1194
01:19:32,000 --> 01:19:36,000
I'm going to give you, that query produces this results. So 

1195
01:19:36,000 --> 01:19:40,000
we only have the items for the order with ID 2, and we 

1196
01:19:40,000 --> 01:19:44,000
have sorted these items based on the total price 

1197
01:19:44,000 --> 01:19:48,000
for each item. So the total price for each item equals quantity times

1198
01:19:48,000 --> 01:19:52,000
unit price. In this case the total price of product 1 is just 

1199
01:19:52,000 --> 01:19:56,000
over 18 dollars. So go ahead and write a query 

1200
01:19:56,000 --> 01:20:00,000
to select all the items for order with ID2. And 

1201
01:20:00,000 --> 01:20:04,000
sort them by their total price in descending order. 

1202
01:20:04,000 --> 01:20:08,000


1203
01:20:08,000 --> 01:20:12,000
Alright, let's select everything from order 

1204
01:20:12,000 --> 01:20:16,000
items, where order id equals 2. 

1205
01:20:16,000 --> 01:20:20,000
that returns all the items for this order. Now we want to make sure 

1206
01:20:20,000 --> 01:20:24,000
to sort them by their total price, so, 

1207
01:20:24,000 --> 01:20:28,000
here in order by clause, we write an expression. Quantity times 

1208
01:20:28,000 --> 01:20:32,000
unit price, this returns the total price for each item. 

1209
01:20:32,000 --> 01:20:36,000
And then we add the descending argument here. So, 

1210
01:20:36,000 --> 01:20:40,000
once again the expression that we use in the order by clause doesn't have to be 

1211
01:20:40,000 --> 01:20:44,000
column name, it can be an alias or an arithmetic expression like this. 

1212
01:20:44,000 --> 01:20:48,000
Let's go ahead and execute this query. This is what we get 

1213
01:20:48,000 --> 01:20:52,000
now for clarity, I would like to add another column in the result 

1214
01:20:52,000 --> 01:20:56,000
So, let's say quantity times unit

1215
01:20:56,000 --> 01:21:00,000
_price. We give it an alias like total 

1216
01:21:00,000 --> 01:21:04,000
price. Let's execute the query, you can clearly 

1217
01:21:04,000 --> 01:21:08,000
see, that this data ia sorted by the total rice in descending order. 

1218
01:21:08,000 --> 01:21:12,000
However, there is a bit of duplication in our query, you have to

1219
01:21:12,000 --> 01:21:16,000
repeated this expression in two places. So now we can simplify our 

1220
01:21:16,000 --> 01:21:20,000
by clause, by using an alias that is total price. 

1221
01:21:20,000 --> 01:21:24,000
And we gwet the exact same result. Net I'm going to show you

1222
01:21:24,000 --> 01:21:28,000
how to mimic the number of records returned form your queries. 

1223
01:21:28,000 --> 01:21:32,000


1224
01:21:32,000 --> 01:21:36,000
In this tutorial, I'm going to show you how to limit the 

1225
01:21:36,000 --> 01:21:40,000
records returned from the query. For example, when we return this query 

1226
01:21:40,000 --> 01:21:44,000
we get all the customers in the customer, table, so we have to 

1227
01:21:44,000 --> 01:21:48,000
ten customers here. Now what if we only want to get, 

1228
01:21:48,000 --> 01:21:52,000
the first 3 customers. That's where we use the limit clause. 

1229
01:21:52,000 --> 01:21:56,000
Let me show you. So, after from, you type out

1230
01:21:56,000 --> 01:22:00,000
limit 3, and this will return only the first 3 

1231
01:22:00,000 --> 01:22:04,000
customers. Now if the argument that we pass here is

1232
01:22:04,000 --> 01:22:08,000
greater than the number of records that our query produces, we'll get 

1233
01:22:08,000 --> 01:22:12,000
the records in the query result. For example, if I pass 300 here, 

1234
01:22:12,000 --> 01:22:16,000
obviously we don't have 300 customers in this table, so when

1235
01:22:16,000 --> 01:22:20,000
we execute this query. We get all the ten customers in this table. 

1236
01:22:20,000 --> 01:22:24,000
So this is how the limit clause works. 

1237
01:22:24,000 --> 01:22:28,000
Now here we can optionally supply an offset, and this is very 

1238
01:22:28,000 --> 01:22:32,000
useful in situations where you want to paginate the data. For example, 

1239
01:22:32,000 --> 01:22:36,000
let's say we have a website, and on this website we have a web page for

1240
01:22:36,000 --> 01:22:40,000
the user to see all the customers int he database. Now for simplicity 

1241
01:22:40,000 --> 01:22:44,000
let's imagine, we want to show only there customers per page. So, 

1242
01:22:44,000 --> 01:22:48,000
what are the customer's you're going to have on page 1? We're going to have 

1243
01:22:48,000 --> 01:22:52,000
customers 123. On page

1244
01:22:52,000 --> 01:22:56,000
2 we're going to have customers 456 and on

1245
01:22:56,000 --> 01:23:00,000
page 3 we're going to have customers 789. 

1246
01:23:00,000 --> 01:23:04,000
Now, let's say we want to write a query to retrieve the customers on page 3. 

1247
01:23:04,000 --> 01:23:08,000
How can we do that? Well, you want to skip the first 

1248
01:23:08,000 --> 01:23:12,000
6 records and then pick 3 records. So, 

1249
01:23:12,000 --> 01:23:16,000
we change our limit clause to something like this. 6

1250
01:23:16,000 --> 01:23:20,000
and 3. So 6 is what we call an offset. 

1251
01:23:20,000 --> 01:23:24,000
And that basically tells MySQL to skip the first records 

1252
01:23:24,000 --> 01:23:28,000
and then take 3 records. Let's execute this

1253
01:23:28,000 --> 01:23:32,000
query. Alright, now we get 

1254
01:23:32,000 --> 01:23:36,000
customers 789. 

1255
01:23:36,000 --> 01:23:40,000
Now, for your 

1256
01:23:40,000 --> 01:23:44,000
exercise, I want you to get the top 3 loyal customers. These

1257
01:23:44,000 --> 01:23:48,000
are the customers that have more points then everyone else. 

1258
01:23:48,000 --> 01:23:52,000


1259
01:23:52,000 --> 01:23:56,000
Alright, first we select everything from the customers table, 

1260
01:23:56,000 --> 01:24:00,000
now we need to order these customers by their points, 

1261
01:24:00,000 --> 01:24:04,000
in descending order. So if you look at the query result 

1262
01:24:04,000 --> 01:24:08,000
you can see that customers are sorted by their loyalty. So, 

1263
01:24:08,000 --> 01:24:12,000
the most loyal customers come first, now we want to pick 

1264
01:24:12,000 --> 01:24:16,000
only the first three customers, and that's where 

1265
01:24:16,000 --> 01:24:20,000
we sue the limit clause, so limit, 

1266
01:24:20,000 --> 01:24:24,000
let's execute this query. And these are the 

1267
01:24:24,000 --> 01:24:28,000
most loyal customers, customers with id's 56

1268
01:24:28,000 --> 01:24:32,000
and 3. Now, here's one thing I want you to remember and that is 

1269
01:24:32,000 --> 01:24:36,000
the order of the limit clause. The limit clause should always 

1270
01:24:36,000 --> 01:24:40,000
come at the end. So first we have the select clause and then

1271
01:24:40,000 --> 01:24:44,000
we have from optionally you can have where followed by

1272
01:24:44,000 --> 01:24:48,000
order by and finally limit. Order of these clauses matter 

1273
01:24:48,000 --> 01:24:52,000
If you change the order MySQL is going to yell at you. So

1274
01:24:52,000 --> 01:24:56,000
pay attention to the order when writing your queries. 

1275
01:24:56,000 --> 01:25:00,000


1276
01:25:00,000 --> 01:25:04,000
So far you have only selected columns from a single but in a real 

1277
01:25:04,000 --> 01:25:08,000
world, we quite often select columns from multiple tables. And that's what I'm going to show you

1278
01:25:08,000 --> 01:25:12,000
over the next few tutorials, so on the left side if you put 

1279
01:25:12,000 --> 01:25:16,000
our orders table. Let's select all the data here, 

1280
01:25:16,000 --> 01:25:20,000
in this table we're using the customer id column to identify the customer 

1281
01:25:20,000 --> 01:25:24,000
that has placed each order. Now as I have told you before 

1282
01:25:24,000 --> 01:25:28,000
we don't store customers information here like their phone number, their email their address, 

1283
01:25:28,000 --> 01:25:32,000
because this information can change in the future. And if 

1284
01:25:32,000 --> 01:25:36,000
even a customer has placed multiple orders then we have to

1285
01:25:36,000 --> 01:25:40,000
change multiple records, you don't want to do that. That's why we have separate tables 

1286
01:25:40,000 --> 01:25:44,000
for customers and orders. Now in this tutorial I'm going to show you

1287
01:25:44,000 --> 01:25:48,000
how to select the orders in the orders table, but instead of showing the customer

1288
01:25:48,000 --> 01:25:52,000
id, we showed full name for each customer. So lets go back

1289
01:25:52,000 --> 01:25:56,000
to our query window. Okay, so, 

1290
01:25:56,000 --> 01:26:00,000
we want to select everything from the orders table. Now we should combine the 

1291
01:26:00,000 --> 01:26:04,000
columns in this table with he columns in the customers table. That 

1292
01:26:04,000 --> 01:26:08,000
is where we use the join keyword. And here we can optionally 

1293
01:26:08,000 --> 01:26:12,000
type inner join, because we in SQL we have two types of join

1294
01:26:12,000 --> 01:26:16,000
inner join and over join. You'll look at outer joins later in this section, 

1295
01:26:16,000 --> 01:26:20,000
so for now we are only using inner join and these inner keyword, 

1296
01:26:20,000 --> 01:26:24,000
is actually optional, so we don't have to type it.

1297
01:26:24,000 --> 01:26:28,000
So, you want to join the orders table with the customer

1298
01:26:28,000 --> 01:26:32,000
table. Now, on what basis do we want to join these tables? 

1299
01:26:32,000 --> 01:26:36,000
Well, here in the customers table, we have this customer id column. 

1300
01:26:36,000 --> 01:26:40,000
So if you put these two tables next to each other you want to line up the records 

1301
01:26:40,000 --> 01:26:44,000
such that the customer ID's are equal. That is where 

1302
01:26:44,000 --> 01:26:48,000
we use the on phrase. So after

1303
01:26:48,000 --> 01:26:52,000
we type out a condition, here's a condition we need to type out, 

1304
01:26:52,000 --> 01:26:56,000
orders.customer_id. Should be equal to 

1305
01:26:56,000 --> 01:27:00,000
customers.customer id. 

1306
01:27:00,000 --> 01:27:04,000
Now, this is getting outside of the screen, so let's break up the line, 

1307
01:27:04,000 --> 01:27:08,000
that's better, so with this query, we're

1308
01:27:08,000 --> 01:27:12,000
telling MySQl that hey, whenever you're going the orders table 

1309
01:27:12,000 --> 01:27:16,000
with the customers table, make sure that the customer ID column, 

1310
01:27:16,000 --> 01:27:20,000
in the orders table, equals the customer ID 

1311
01:27:20,000 --> 01:27:24,000
column, in the customers table. Now let's execute this query, 

1312
01:27:24,000 --> 01:27:28,000
look at the result, 

1313
01:27:28,000 --> 01:27:32,000
since we are selecting everything here, the first few columns are

1314
01:27:32,000 --> 01:27:36,000
from the orders table, because we have listed that first 

1315
01:27:36,000 --> 01:27:40,000
now after all the columns in the 

1316
01:27:40,000 --> 01:27:44,000
customer table. So customer ID first name, last name and so on. 

1317
01:27:44,000 --> 01:27:48,000
Now let's simplify the result set and select only 

1318
01:27:48,000 --> 01:27:52,000
border id, first name, and last name, so query 

1319
01:27:52,000 --> 01:27:56,000
we select order ID, first 

1320
01:27:56,000 --> 01:28:00,000
name, and last name. Now let's execute the query 

1321
01:28:00,000 --> 01:28:04,000
that is better. So next to each order ID, you can see the 

1322
01:28:04,000 --> 01:28:08,000
name of the customer that placed that order. Now what if you want to display 

1323
01:28:08,000 --> 01:28:12,000
the customer ID here as well. Well, let's put that here and 

1324
01:28:12,000 --> 01:28:16,000
see what happens. Customer ID, execute the query 

1325
01:28:16,000 --> 01:28:20,000
we get an error, so if you look at the output window, down at the bottom, 

1326
01:28:20,000 --> 01:28:24,000
we should see an error saying column, customer id, field this is

1327
01:28:24,000 --> 01:28:28,000
ambiguous. Now unfortunately I cannot show you this error, because the size of my

1328
01:28:28,000 --> 01:28:32,000
recording window is smaller then MySQL workbench. But

1329
01:28:32,000 --> 01:28:36,000
that aside, let me explain why we're getting this error. Because we have this customer ID 

1330
01:28:36,000 --> 01:28:40,000
column in both the orders and the customers table, 

1331
01:28:40,000 --> 01:28:44,000
so MySQL is not sure which table we want to select this

1332
01:28:44,000 --> 01:28:48,000
column from. That is why it's saying this column is ambiguous 

1333
01:28:48,000 --> 01:28:52,000
so we need to qualify this column by prefixing it with a table name. 

1334
01:28:52,000 --> 01:28:56,000
We can either pick it from order table or 

1335
01:28:56,000 --> 01:29:00,000
the customers table, it doesn't really matter, because the values are

1336
01:29:00,000 --> 01:29:04,000
equal, right? So, in situations where you have 

1337
01:29:04,000 --> 01:29:08,000
the same column in multiple tables, you need to qualify them, 

1338
01:29:08,000 --> 01:29:12,000
by prefixing them with the name of the table, okay, now, 

1339
01:29:12,000 --> 01:29:16,000
we say tot he query one more time, there you go, you have order ID, 

1340
01:29:16,000 --> 01:29:20,000
customer ID and the full name. Now one more thing 

1341
01:29:20,000 --> 01:29:24,000
before we finish this tutorial, if you pay close attention we have repeated the word 

1342
01:29:24,000 --> 01:29:28,000
orders in multipel places, you have it here, as well as 

1343
01:29:28,000 --> 01:29:32,000
in the join condition, the same is true about he customers table, you

1344
01:29:32,000 --> 01:29:36,000
have repeated that here. We can get rid of this repetition 

1345
01:29:36,000 --> 01:29:40,000
and make our code simpler by using an alias. So write 

1346
01:29:40,000 --> 01:29:44,000
after each table you can do it in alias, 

1347
01:29:44,000 --> 01:29:48,000
as a short for orders, so by convention we abbreviate the table's name. 

1348
01:29:48,000 --> 01:29:52,000
Now, wherever we have orders you should replace that with 

1349
01:29:52,000 --> 01:29:56,000
o. So here in the join condition, we're going to replace orders 

1350
01:29:56,000 --> 01:30:00,000
with o, and also one more time, in the select 

1351
01:30:00,000 --> 01:30:04,000
clause. There you go. You can also apply an alias for 

1352
01:30:04,000 --> 01:30:08,000
a customer's table, call it c, and then simplify 

1353
01:30:08,000 --> 01:30:12,000
our join condition like this. So this is how we can join 

1354
01:30:12,000 --> 01:30:16,000
columns for multiple tables. 

1355
01:30:16,000 --> 01:30:20,000
Now for your 

1356
01:30:20,000 --> 01:30:24,000
exercise, I want you to look at the order items table. 

1357
01:30:24,000 --> 01:30:28,000
So, in this table we have these columns, order ID, column ID, 

1358
01:30:28,000 --> 01:30:32,000
product id, quantity, and unit price. Now I want you to write a query 

1359
01:30:32,000 --> 01:30:36,000
and join this table with the products table so for each order 

1360
01:30:36,000 --> 01:30:40,000
return both the product id as well as this name, followed by the 

1361
01:30:40,000 --> 01:30:44,000
quantity, and the unit price form the order items table. And by the way 

1362
01:30:44,000 --> 01:30:48,000
make sure to use an alias to simplify your code, 

1363
01:30:48,000 --> 01:30:52,000


1364
01:30:52,000 --> 01:30:56,000
Alright, first let's select everything from the order 

1365
01:30:56,000 --> 01:31:00,000
items table, and then join it with the 

1366
01:31:00,000 --> 01:31:04,000
products table. How are we going to join this table. On

1367
01:31:04,000 --> 01:31:08,000
order_items. Well actually 

1368
01:31:08,000 --> 01:31:12,000
let's just keep this on Alias right away, so we use oi, 

1369
01:31:12,000 --> 01:31:16,000
as an abbreviation for order items. And p as 

1370
01:31:16,000 --> 01:31:20,000
a short for products. So oi.product

1371
01:31:20,000 --> 01:31:24,000
id, should be equal to p or products.

1372
01:31:24,000 --> 01:31:28,000
product id. And by the way, remember that

1373
01:31:28,000 --> 01:31:32,000
alias for table, you have to use that alias everywhere. So here

1374
01:31:32,000 --> 01:31:36,000
I cannot type out product, MySQL is going to yell at me. So

1375
01:31:36,000 --> 01:31:40,000
let's use the abbreviation. Alright, this is how we join these tables, 

1376
01:31:40,000 --> 01:31:44,000
let's execute this query up to this point. Alright, 

1377
01:31:44,000 --> 01:31:48,000
so we see all the items form the order items table, followed by 

1378
01:31:48,000 --> 01:31:52,000
from the products table. Now, you want 

1379
01:31:52,000 --> 01:31:56,000
to explicit select a few column here. So, to 

1380
01:31:56,000 --> 01:32:00,000
order items table you want to select order_id. 

1381
01:32:00,000 --> 01:32:04,000
We take it then we don't have to prefix it with a table name 

1382
01:32:04,000 --> 01:32:08,000
because this calumnies not repeated in multiple places, so it's not ambiguous. 

1383
01:32:08,000 --> 01:32:12,000
So, let's make the code shorter, that's better, now 

1384
01:32:12,000 --> 01:32:16,000
we want to select the product ID column, but because this column exists

1385
01:32:16,000 --> 01:32:20,000
in both tables, you have to both prefix it with a column name.

1386
01:32:20,000 --> 01:32:24,000
Either oi or p it doesn't really matter. So, 

1387
01:32:24,000 --> 01:32:28,000
next, we want to select quantity, and finally you want 

1388
01:32:28,000 --> 01:32:32,000
price. Now actually here, you have this unit price column. 

1389
01:32:32,000 --> 01:32:36,000
In both tables, so this is the unit price in order items table 

1390
01:32:36,000 --> 01:32:40,000
and this is the unit price in the products table, 

1391
01:32:40,000 --> 01:32:44,000
now you might be curious why we have this column in 2 places, 

1392
01:32:44,000 --> 01:32:48,000
is that the price of product can change, so for each 

1393
01:32:48,000 --> 01:32:52,000
order item, you want to have the price at the time the user 

1394
01:32:52,000 --> 01:32:56,000
placed the order. So this is a snapshot of the price 

1395
01:32:56,000 --> 01:33:00,000
at a given point in time. The unit price that we have for the products table 

1396
01:33:00,000 --> 01:33:04,000
is the current price right now. This is very important for the 

1397
01:33:04,000 --> 01:33:08,000
recording, otherwise we cannot calculate the sales properly. So, 

1398
01:33:08,000 --> 01:33:12,000
because we have the unit price column in two places, in this case we should pick it

1399
01:33:12,000 --> 01:33:16,000
from the quarter items table because this is the price at the time of

1400
01:33:16,000 --> 01:33:20,000
now, let's execute query. So here's 

1401
01:33:20,000 --> 01:33:24,000
the final result. 

1402
01:33:24,000 --> 01:33:28,000
In the real world, when you

1403
01:33:28,000 --> 01:33:32,000
work as a developer or a data base administrator quite often you will 

1404
01:33:32,000 --> 01:33:36,000
have to work with multiple databases. In this tutorial I'm going to show you how

1405
01:33:36,000 --> 01:33:40,000
to combine columns from tables in multiple places. 

1406
01:33:40,000 --> 01:33:44,000
That's pretty easy. So, in the SQL store database, you have this tables 

1407
01:33:44,000 --> 01:33:48,000
that you're fairly familiar with. Now imagine this products table

1408
01:33:48,000 --> 01:33:52,000
was not here. Now, if you look at the 

1409
01:33:52,000 --> 01:33:56,000
database, you can see here another products table, this

1410
01:33:56,000 --> 01:34:00,000
products table is exactly the same as the products table that we have 

1411
01:34:00,000 --> 01:34:04,000
in a SQL store database, so it has the same columns and the same data. 

1412
01:34:04,000 --> 01:34:08,000
Now technically this is not a good design, you don't want to have the same table 

1413
01:34:08,000 --> 01:34:12,000
repeated in multiple places. But for this demo, let's just imagine 

1414
01:34:12,000 --> 01:34:16,000
that we don't have the products table here, so we want to join the 

1415
01:34:16,000 --> 01:34:20,000
order items table, with the products table in the SQL

1416
01:34:20,000 --> 01:34:24,000
inventory database. Let's get started. So select 

1417
01:34:24,000 --> 01:34:28,000
everything from the order items table, 

1418
01:34:28,000 --> 01:34:32,000
let's give it an alias straight away, you want to join this with

1419
01:34:32,000 --> 01:34:36,000
the products table. This products table is part of the products inventory 

1420
01:34:36,000 --> 01:34:40,000
database. So we'll have to prefix this with the name of it's database. 

1421
01:34:40,000 --> 01:34:44,000
So, we type out SQL inventory.

1422
01:34:44,000 --> 01:34:48,000
Now once again we can give this an alias like p, 

1423
01:34:48,000 --> 01:34:52,000
then type out our joint condition, so oi.product 

1424
01:34:52,000 --> 01:34:56,000
id should be the same as p.product id. 

1425
01:34:56,000 --> 01:35:00,000
Let's run the query there you go, so we successfully joined 

1426
01:35:00,000 --> 01:35:04,000
tables across multiple databases. Now note that

1427
01:35:04,000 --> 01:35:08,000
we're prefixing the products table with the name of the database because 

1428
01:35:08,000 --> 01:35:12,000
the current database that we're writing this query with is the SQL stored 

1429
01:35:12,000 --> 01:35:16,000
database. Take a look, in the navigator panel, in the SQL 

1430
01:35:16,000 --> 01:35:20,000
store database is displayed in full. Because earlier, the 

1431
01:35:20,000 --> 01:35:24,000
root we use statement to select 

1432
01:35:24,000 --> 01:35:28,000
a database, that will SQL store. Now what if we select 

1433
01:35:28,000 --> 01:35:32,000
the SQL inventory database. So, let's see what happens SQL 

1434
01:35:32,000 --> 01:35:36,000
inventory, now because we have multiple statements we have 

1435
01:35:36,000 --> 01:35:40,000
to terminate this with a semi colon. Now we want to select everything with a 

1436
01:35:40,000 --> 01:35:44,000
order items table. But we don't have this table inside of this 

1437
01:35:44,000 --> 01:35:48,000
database. So now we'll have to prefix this table 

1438
01:35:48,000 --> 01:35:52,000
with the name of it's database, that is SQL underline 

1439
01:35:52,000 --> 01:35:56,000
story. Let's execute the query, okay, 

1440
01:35:56,000 --> 01:36:00,000
everything works, beautifully. So here's the lesson. You only have to 

1441
01:36:00,000 --> 01:36:04,000
prefix the tables that are not part of the current database. In other words

1442
01:36:04,000 --> 01:36:08,000
the query will be different depending on the database. 

1443
01:36:08,000 --> 01:36:12,000


1444
01:36:12,000 --> 01:36:16,000
In SQL we can also join a table with

1445
01:36:16,000 --> 01:36:20,000
itself. Let me show you an example. Take a look at this database. 

1446
01:36:20,000 --> 01:36:24,000
SQL hr, in this database we have 

1447
01:36:24,000 --> 01:36:28,000
these two tables, employees and offices. Let's take a look at the 

1448
01:36:28,000 --> 01:36:32,000
data int he employees table. 

1449
01:36:32,000 --> 01:36:36,000
There you go. So here we have these columns, 

1450
01:36:36,000 --> 01:36:40,000
employee id, first name, last name, salary 

1451
01:36:40,000 --> 01:36:44,000
and reports 2. This is the id of 

1452
01:36:44,000 --> 01:36:48,000
the manager for this person or this employee. Now once again, 

1453
01:36:48,000 --> 01:36:52,000
you don't want to repeat the managers information here, like the phone number, the address

1454
01:36:52,000 --> 01:36:56,000
because this information can change in the future, so we are only using 

1455
01:36:56,000 --> 01:37:00,000
your identifier or their id to refer to them in this table, 

1456
01:37:00,000 --> 01:37:04,000
now where can we find information about this

1457
01:37:04,000 --> 01:37:08,000
This manager is actually an employee of the same organization, so, 

1458
01:37:08,000 --> 01:37:12,000
look at this example, the manager ID is 37

1459
01:37:12,000 --> 01:37:16,000
370. Now if you look on the website, here is the ID of

1460
01:37:16,000 --> 01:37:20,000
that manager which is another employee. That was the manager for this

1461
01:37:20,000 --> 01:37:24,000
employee. We don't have any values here so 

1462
01:37:24,000 --> 01:37:28,000
the value for the sale is null. So this employee doesn't have a manager 

1463
01:37:28,000 --> 01:37:32,000
and that means they are the CEO. So let's go ahead and 

1464
01:37:32,000 --> 01:37:36,000
write a query to join this table with itself so we can select the name of

1465
01:37:36,000 --> 01:37:40,000
each employee and their manager. Back to our query window, 

1466
01:37:40,000 --> 01:37:44,000
first we need to select the SQL hr database. 

1467
01:37:44,000 --> 01:37:48,000
Next, we select everything from 

1468
01:37:48,000 --> 01:37:52,000
the employees table, we give an alias like

1469
01:37:52,000 --> 01:37:56,000
b now we need to join this table with itself. So once again we type 

1470
01:37:56,000 --> 01:38:00,000
out the employees, but we need a different alias. What should we 

1471
01:38:00,000 --> 01:38:04,000
call this alias. Well you want to join this table with itself so we can 

1472
01:38:04,000 --> 01:38:08,000
find the managers right? So we can use m as a shortcut 

1473
01:38:08,000 --> 01:38:12,000
for managers. Now, let's type our our joint condition. 

1474
01:38:12,000 --> 01:38:16,000
So from the employees table, we need to join 

1475
01:38:16,000 --> 01:38:20,000
the reports_2 column. To the manager 

1476
01:38:20,000 --> 01:38:24,000
table which is basically an employees table itself, and 

1477
01:38:24,000 --> 01:38:28,000
that is employee_

1478
01:38:28,000 --> 01:38:32,000
id. Now let's execute this query and see what we get. 

1479
01:38:32,000 --> 01:38:36,000
So, we see all the columns from the employees table 

1480
01:38:36,000 --> 01:38:40,000
repeated the first set of columns, represent the information about the 

1481
01:38:40,000 --> 01:38:44,000
employees, and after that, we have the information about the managers

1482
01:38:44,000 --> 01:38:48,000
in this case we have only one manager in this table. 

1483
01:38:48,000 --> 01:38:52,000
But with this technique we can easily create an organization trial. We can have 

1484
01:38:52,000 --> 01:38:56,000
a hierarchy of managers. Now let's 

1485
01:38:56,000 --> 01:39:00,000
only the name of the employee and the manager. So, 

1486
01:39:00,000 --> 01:39:04,000
right here, since every column in the employees table is 

1487
01:39:04,000 --> 01:39:08,000
repeated twice we need to prefix each column with a table name. 

1488
01:39:08,000 --> 01:39:12,000
For example, from the employee's table you want to get

1489
01:39:12,000 --> 01:39:16,000
employee ID, as well as the first 

1490
01:39:16,000 --> 01:39:20,000
name, and then for the managers table, we want to select 

1491
01:39:20,000 --> 01:39:24,000
the first name as well. So every column 

1492
01:39:24,000 --> 01:39:28,000
should be prefixed with a table name or more accurately the alias because

1493
01:39:28,000 --> 01:39:32,000
all these columns exist in two tables, right? 

1494
01:39:32,000 --> 01:39:36,000
Let's go ahead and execute this query, so, 

1495
01:39:36,000 --> 01:39:40,000
this is what we get, employee id, and here's the managers 

1496
01:39:40,000 --> 01:39:44,000
first name. We can improve this query by giving an alias to this

1497
01:39:44,000 --> 01:39:48,000
column. Because it doesn't make sense to have two first name columns. 

1498
01:39:48,000 --> 01:39:52,000
So, let's give an alias to the third column, 

1499
01:39:52,000 --> 01:39:56,000
manager. Now, let's execute it one more time. 

1500
01:39:56,000 --> 01:40:00,000
And, here's the end result. So, we have

1501
01:40:00,000 --> 01:40:04,000
the empty ID first name, and object. So, 

1502
01:40:04,000 --> 01:40:08,000
joining a table with itself is pretty much the same as joining a table with

1503
01:40:08,000 --> 01:40:12,000
another table. The only difference is that we have to use 

1504
01:40:12,000 --> 01:40:16,000
different alias's. And we have to prefix each column with an alias. 

1505
01:40:16,000 --> 01:40:20,000
This is what we call a self join. Next, I'm going to show you

1506
01:40:20,000 --> 01:40:24,000
how to join more then two tables. 

1507
01:40:24,000 --> 01:40:28,000
In this tutorial, 

1508
01:40:28,000 --> 01:40:32,000
I'm going to show you how to join more then two tables in writing a 

1509
01:40:32,000 --> 01:40:36,000
query. For example, back to our SQL database, look at the 

1510
01:40:36,000 --> 01:40:40,000
orders table, now you know how to write a query to join this

1511
01:40:40,000 --> 01:40:44,000
table with the customers table to return information about the customer

1512
01:40:44,000 --> 01:40:48,000
to place each order. But here we also have another column, 

1513
01:40:48,000 --> 01:40:52,000
status, which is similar to the customer ID status. So the name of the 

1514
01:40:52,000 --> 01:40:56,000
status's are not stored in this table, they are somewhere else in the 

1515
01:40:56,000 --> 01:41:00,000
order status's table. Let's have a quick look here. 

1516
01:41:00,000 --> 01:41:04,000
Our orders can be either processed, shipped or delivered. And these are

1517
01:41:04,000 --> 01:41:08,000
the identifiers for each of these status's. Now back to our

1518
01:41:08,000 --> 01:41:12,000
orders table. In the status column you store

1519
01:41:12,000 --> 01:41:16,000
status id. So now we should write a query to join the orders

1520
01:41:16,000 --> 01:41:20,000
table, be two tables. The customers table and orders 

1521
01:41:20,000 --> 01:41:24,000
status's table. The result of this query is going to look like this. 

1522
01:41:24,000 --> 01:41:28,000
So for each order we see the order id, the date, 

1523
01:41:28,000 --> 01:41:32,000
the first and last name of the customer, and finally the status of the order. 

1524
01:41:32,000 --> 01:41:36,000
This is a beautiful report we can create for our users. So let me

1525
01:41:36,000 --> 01:41:40,000
show you how to write this query. Back to our query editor, first we need to select 

1526
01:41:40,000 --> 01:41:44,000
the SQL store database, now, we need to select 

1527
01:41:44,000 --> 01:41:48,000
everything from the orders table, that's going to be the alias, 

1528
01:41:48,000 --> 01:41:52,000
next we need to join this with the customers table. 

1529
01:41:52,000 --> 01:41:56,000
On, that customer id should 

1530
01:41:56,000 --> 01:42:00,000
be equal to see the customer id. Nothing 

1531
01:42:00,000 --> 01:42:04,000
new so far. Exactly like before. Now here we can write another

1532
01:42:04,000 --> 01:42:08,000
joint keyword. To join the others keyword 

1533
01:42:08,000 --> 01:42:12,000
order status's table. So we type out order status's. 

1534
01:42:12,000 --> 01:42:16,000
And also give it an alias, OS, 

1535
01:42:16,000 --> 01:42:20,000
what is our join condition? Well, back in the 

1536
01:42:20,000 --> 01:42:24,000
orders table, here we have the status column. So the 

1537
01:42:24,000 --> 01:42:28,000
value in this column should be equal to the order status ID, 

1538
01:42:28,000 --> 01:42:32,000
column in order status's table. Right? So back

1539
01:42:32,000 --> 01:42:36,000
to the query, so orders table.status

1540
01:42:36,000 --> 01:42:40,000
should be equal to order status's.order status

1541
01:42:40,000 --> 01:42:44,000
ID. Make sure to get the name right, otherwise you're going to get

1542
01:42:44,000 --> 01:42:48,000
an error So this is how we can join three tables. 

1543
01:42:48,000 --> 01:42:52,000
Now in the real world as you work on more complex problems, you'll end up joining 

1544
01:42:52,000 --> 01:42:56,000
even ten tables. So this is not uncommon in the SQL world. 

1545
01:42:56,000 --> 01:43:00,000
Now let's go ahead and execute this query. First we get the column 

1546
01:43:00,000 --> 01:43:04,000
from the orders table, followed by the orders from the customers table, 

1547
01:43:04,000 --> 01:43:08,000
and so on. This result is so complex and hard to extract information. 

1548
01:43:08,000 --> 01:43:12,000
from. So, let's explicitly select 

1549
01:43:12,000 --> 01:43:16,000
a few columns here. From the orders table, you want to select 

1550
01:43:16,000 --> 01:43:20,000
the order iD column, as well as the order

1551
01:43:20,000 --> 01:43:24,000
date. Then, from the customers table, we want to select 

1552
01:43:24,000 --> 01:43:28,000
the first name, and last name.

1553
01:43:28,000 --> 01:43:32,000
And finally form the order status's, we select the name 

1554
01:43:32,000 --> 01:43:36,000
column. So we can give this an alias like status

1555
01:43:36,000 --> 01:43:40,000
that's better. Let's execute the query one more time. 

1556
01:43:40,000 --> 01:43:44,000
So, here's the end result, we have order ID, 

1557
01:43:44,000 --> 01:43:48,000
order date, the name of the customer, followed by the status of the order. 

1558
01:43:48,000 --> 01:43:52,000


1559
01:43:52,000 --> 01:43:56,000
Alright, for exercise, take a look at the SQL

1560
01:43:56,000 --> 01:44:00,000
invoicing database. Here we have this table, payments, 

1561
01:44:00,000 --> 01:44:04,000
and these are the payments that each client has made towards either invoice 

1562
01:44:04,000 --> 01:44:08,000
Let's take a look at the data, so we have these columns, 

1563
01:44:08,000 --> 01:44:12,000
like client id, that identifies the client, so we can join this table 

1564
01:44:12,000 --> 01:44:16,000
with the client's table to see the name of the clients. Next we 

1565
01:44:16,000 --> 01:44:20,000
have invoice ID, we also have date, 

1566
01:44:20,000 --> 01:44:24,000
payment method. So similarly we can join this table with the payment method 

1567
01:44:24,000 --> 01:44:28,000
table here, let's have a look at the data in this table, these are the 

1568
01:44:28,000 --> 01:44:32,000
payment methods, credit card, cash, PayPal, wire transfer. So, 

1569
01:44:32,000 --> 01:44:36,000
back to the payments table, I want you to write a query and join this table 

1570
01:44:36,000 --> 01:44:40,000
with the payment methods table as well as the client's table. 

1571
01:44:40,000 --> 01:44:44,000
Produce a report that shows the payments, with more details, such as the name of the client, 

1572
01:44:44,000 --> 01:44:48,000
and the payment method. 

1573
01:44:48,000 --> 01:44:52,000
Alright, first we need to

1574
01:44:52,000 --> 01:44:56,000
use, the SQL invoicing database, now we can 

1575
01:44:56,000 --> 01:45:00,000
select everything from the payments table which we call

1576
01:45:00,000 --> 01:45:04,000
e, next we need to join this with the client's table which we call

1577
01:45:04,000 --> 01:45:08,000
c, on p.clientid 

1578
01:45:08,000 --> 01:45:12,000
should eb equal to c.client id. Let me double 

1579
01:45:12,000 --> 01:45:16,000
check the column name to make sure I got it right, so back to the payments table

1580
01:45:16,000 --> 01:45:20,000
the column is called client item. You also have a column called 

1581
01:45:20,000 --> 01:45:24,000
payment method, that we should join to the payment 

1582
01:45:24,000 --> 01:45:28,000
method ID column of the payment methods table. 

1583
01:45:28,000 --> 01:45:32,000
So, back to the query, once again we use a joint 

1584
01:45:32,000 --> 01:45:36,000
statement here, join with payment methods, we give it an alias 

1585
01:45:36,000 --> 01:45:40,000
pm, on p.

1586
01:45:40,000 --> 01:45:44,000
payment _method should be equal to pm. 

1587
01:45:44,000 --> 01:45:48,000
payment method id. Make sure to type it out correctly 

1588
01:45:48,000 --> 01:45:52,000
otherwise you're going to get an error. So let's go ahead and execute the query 

1589
01:45:52,000 --> 01:45:56,000
up to this point, finally let's hand pick 

1590
01:45:56,000 --> 01:46:00,000
the columns that make the most sense. So, 

1591
01:46:00,000 --> 01:46:04,000
from the payments table, let's select the

1592
01:46:04,000 --> 01:46:08,000
date, followed by invoice id, 

1593
01:46:08,000 --> 01:46:12,000
what else do we have here. So we have client id, invoice 

1594
01:46:12,000 --> 01:46:16,000
id, date, and now the payment method, I'm going to pick the amount 

1595
01:46:16,000 --> 01:46:20,000
column from here as well, so back to the query, p 

1596
01:46:20,000 --> 01:46:24,000
.amount. Now we need to add information about the client. 

1597
01:46:24,000 --> 01:46:28,000
Let's take a look at this table, clients, 

1598
01:46:28,000 --> 01:46:32,000
so here we have columns like name, address, 

1599
01:46:32,000 --> 01:46:36,000
city and so on. All we need here is the name column. So back to the query, 

1600
01:46:36,000 --> 01:46:40,000
of the client's table let's select the name column and 

1601
01:46:40,000 --> 01:46:44,000
finally form the payment method table, let's select, what is that column called

1602
01:46:44,000 --> 01:46:48,000
it's called name. So back to the query

1603
01:46:48,000 --> 01:46:52,000
pm.name. So here's the end result. 

1604
01:46:52,000 --> 01:46:56,000
Now we can put this column in any order that we want, it doesn't really matter, 

1605
01:46:56,000 --> 01:47:00,000
let's execute the query, and make sure everything works. 

1606
01:47:00,000 --> 01:47:04,000
So, on this date, on this invoice, 

1607
01:47:04,000 --> 01:47:08,000
we have a payment for this amount by this client using a 

1608
01:47:08,000 --> 01:47:12,000
credit card. 

1609
01:47:12,000 --> 01:47:16,000
Ina let he examples you have seen so far, 

1610
01:47:16,000 --> 01:47:20,000
we use a single column to uniquely identify the rows 

1611
01:47:20,000 --> 01:47:24,000
in a given table. For example, for example, in the customers table, 

1612
01:47:24,000 --> 01:47:28,000
we have this customer ID column which uniquely identifies 

1613
01:47:28,000 --> 01:47:32,000
the rows in this table. But there are times where we cannot use a single 

1614
01:47:32,000 --> 01:47:36,000
column to uniquely identify columns in a given table. For example,

1615
01:47:36,000 --> 01:47:40,000
look at the order items table. In this

1616
01:47:40,000 --> 01:47:44,000
table, we have columns like order id, product id, and so on. Now if you look at 

1617
01:47:44,000 --> 01:47:48,000
the data, you can see that the values in the order id column are repeated. 

1618
01:47:48,000 --> 01:47:52,000
They are duplicated. You have 2226 and so on.

1619
01:47:52,000 --> 01:47:56,000
So we cannot use this column on it's own to uniquely identify each record. 

1620
01:47:56,000 --> 01:48:00,000
The same is true for the product id. The values for this column 

1621
01:48:00,000 --> 01:48:04,000
are also duplicated. So in this table we use the combination of

1622
01:48:04,000 --> 01:48:08,000
the values in both these columns to uniquely identify 

1623
01:48:08,000 --> 01:48:12,000
each oder item. As an example, in this order we have 

1624
01:48:12,000 --> 01:48:16,000
3 items, for products, 1, 4, and 6, and 

1625
01:48:16,000 --> 01:48:20,000
for each product, we have a quantity and unit price.

1626
01:48:20,000 --> 01:48:24,000
So if we use the combination of the values in both these values, 

1627
01:48:24,000 --> 01:48:28,000
we can uniquely identify each order item, in other words, we don't have 

1628
01:48:28,000 --> 01:48:32,000
two records for order ID 2, and product ID 1, 

1629
01:48:32,000 --> 01:48:36,000
we only have a single record for that item, 

1630
01:48:36,000 --> 01:48:40,000
now let's open this table in the design mode. So over here we 

1631
01:48:40,000 --> 01:48:44,000
find this middle icon that looks like a tool. Note that this yellow 

1632
01:48:44,000 --> 01:48:48,000
key that represents the primary key exists on both these columns. 

1633
01:48:48,000 --> 01:48:52,000
This is what we call a composite primary key. The composite primary key 

1634
01:48:52,000 --> 01:48:56,000
contains more then one column. Now why does this matter? 

1635
01:48:56,000 --> 01:49:00,000
Well, when you have a table with a composite primary key. 

1636
01:49:00,000 --> 01:49:04,000
You need to learn how to join that table with other tables. For example, 

1637
01:49:04,000 --> 01:49:08,000
here we have this table, order item notes, that we use to keep

1638
01:49:08,000 --> 01:49:12,000
notes in each order item. Let's look at the data here. 

1639
01:49:12,000 --> 01:49:16,000
So we have this column note id, right? Which uniquely identifies the 

1640
01:49:16,000 --> 01:49:20,000
records in this table, next to that we have order ID and product ID. 

1641
01:49:20,000 --> 01:49:24,000
you learn that the combination of these two columns uniquely represents 

1642
01:49:24,000 --> 01:49:28,000
and order ID. So here for order number 2, 

1643
01:49:28,000 --> 01:49:32,000
for product number 1, we have two notes. Now let me show you how

1644
01:49:32,000 --> 01:49:36,000
join this table with the order items table. So, back to our 

1645
01:49:36,000 --> 01:49:40,000
query, you can see that I have already selected the SQL store

1646
01:49:40,000 --> 01:49:44,000
database, so I'm not going to type out a U statement. Alright, let's select 

1647
01:49:44,000 --> 01:49:48,000
like everything from the order 

1648
01:49:48,000 --> 01:49:52,000
items table. Give it an alias, now we need to

1649
01:49:52,000 --> 01:49:56,000
join this with order item notes, also 

1650
01:49:56,000 --> 01:50:00,000
we give it an alias. How are we going to join these tables? 

1651
01:50:00,000 --> 01:50:04,000
Based on two columns, back to the order items table 

1652
01:50:04,000 --> 01:50:08,000
these are the columns that we need to use in our joint condition. 

1653
01:50:08,000 --> 01:50:12,000
So, in the order items table we have this 

1654
01:50:12,000 --> 01:50:16,000
order ID column, these should be equal to the

1655
01:50:16,000 --> 01:50:20,000
same column in order item notes table. So, 

1656
01:50:20,000 --> 01:50:24,000
in.order id. But this is not enough, 

1657
01:50:24,000 --> 01:50:28,000
we should also join these tables based on the product ID number. 

1658
01:50:28,000 --> 01:50:32,000
So, we type out and, and then type out the 

1659
01:50:32,000 --> 01:50:36,000
second condition, so order items.

1660
01:50:36,000 --> 01:50:40,000
product ID should be equal to order item notes.product 

1661
01:50:40,000 --> 01:50:44,000
id. This is what we call a compound joint 

1662
01:50:44,000 --> 01:50:48,000
condition. So we have multiple conditions to join these

1663
01:50:48,000 --> 01:50:52,000
two tables. 

1664
01:50:52,000 --> 01:50:56,000
In this tutorial 

1665
01:50:56,000 --> 01:51:00,000
I'm going to talk about the implicit joint syntax in MySQL. 

1666
01:51:00,000 --> 01:51:04,000
So here we have a basic inner join, we're selecting everything from the orders table, 

1667
01:51:04,000 --> 01:51:08,000
joining it with customers table on, orders.customer

1668
01:51:08,000 --> 01:51:12,000
id. Equal to customers.customerid. Pretty basic. 

1669
01:51:12,000 --> 01:51:16,000
There is another way to write this query using implicit join 

1670
01:51:16,000 --> 01:51:20,000
syntax. Let me show you how this works. So, 

1671
01:51:20,000 --> 01:51:24,000
we select everything 

1672
01:51:24,000 --> 01:51:28,000
from now here we can type out multiple table names. 

1673
01:51:28,000 --> 01:51:32,000
so, orders, customers. 

1674
01:51:32,000 --> 01:51:36,000
And we can also give them an alias, so c and 

1675
01:51:36,000 --> 01:51:40,000
o. And then we move this join condition, 

1676
01:51:40,000 --> 01:51:44,000
to the where clause, so I'm going to copy this from here, 

1677
01:51:44,000 --> 01:51:48,000
type out the where clause, and paste the condition. These two queries, 

1678
01:51:48,000 --> 01:51:52,000
are equivalent. What we have here is called implicit 

1679
01:51:52,000 --> 01:51:56,000
joint syntax. Now even though MySQL supports the syntax 

1680
01:51:56,000 --> 01:52:00,000
it's something that I suggest you not to use, because if you accidentally forget 

1681
01:52:00,000 --> 01:52:04,000
to type out the where clause, you will get a cross join. Let me show you

1682
01:52:04,000 --> 01:52:08,000
what I mean. So first I'm going to delete the first query. 

1683
01:52:08,000 --> 01:52:12,000
And execute this 

1684
01:52:12,000 --> 01:52:16,000
so we get ten records because we have 

1685
01:52:16,000 --> 01:52:20,000
10 orders in this database. So far so good. What happens

1686
01:52:20,000 --> 01:52:24,000
if you accidentally type out

1687
01:52:24,000 --> 01:52:28,000
the where clause. Instead of 10 records we're going to get 

1688
01:52:28,000 --> 01:52:32,000
probably 100 records. Because every record

1689
01:52:32,000 --> 01:52:36,000
in the order table, is now joined with every record in the 

1690
01:52:36,000 --> 01:52:40,000
customers table. This is what we call a cross turn. Now later in this

1691
01:52:40,000 --> 01:52:44,000
section I'm going to talk about cross joins in more detail, but what I want to talk about 

1692
01:52:44,000 --> 01:52:48,000
in this tutorial, is that it's better to use an explicit 

1693
01:52:48,000 --> 01:52:52,000
joint syntax, so, we use, join 

1694
01:52:52,000 --> 01:52:56,000
because this syntax forces you to type out the joint condition, if 

1695
01:52:56,000 --> 01:53:00,000
you simply join orders with customers, without typing 

1696
01:53:00,000 --> 01:53:04,000
the join condition, you're going to get a syntax error. So to recap, 

1697
01:53:04,000 --> 01:53:08,000
be aware of the implicit join syntax, but write all of 

1698
01:53:08,000 --> 01:53:12,000
your joints using the explicit syntax. 

1699
01:53:12,000 --> 01:53:16,000


1700
01:53:16,000 --> 01:53:20,000
Earlier in this section I told you that in SQL we have two types of forms. 

1701
01:53:20,000 --> 01:53:24,000
Inner joins and outer joins. And so far you have 

1702
01:53:24,000 --> 01:53:28,000
only seen examples of inner joins. And I also told you that this inner keyword is 

1703
01:53:28,000 --> 01:53:32,000
optional, so whenever you type out a join, you're using an inner join. 

1704
01:53:32,000 --> 01:53:36,000
In this tutorial, we're going to look at outer joins and the problems they

1705
01:53:36,000 --> 01:53:40,000
solve. So, let's start by writing a query that uses an 

1706
01:53:40,000 --> 01:53:44,000
inner join, and then we'll convert hat inner join and outer join. 

1707
01:53:44,000 --> 01:53:48,000
So, select everything from the customers table 

1708
01:53:48,000 --> 01:53:52,000
join it in the orders table, 

1709
01:53:52,000 --> 01:53:56,000
on c.customer id should be equal to 

1710
01:53:56,000 --> 01:54:00,000
o.customer ID. Pretty basic 

1711
01:54:00,000 --> 01:54:04,000
right? Now for clarity, let's pick a few columns from these

1712
01:54:04,000 --> 01:54:08,000
two tables .So for the customers table I want to pick customer 

1713
01:54:08,000 --> 01:54:12,000
id. And first name, 

1714
01:54:12,000 --> 01:54:16,000
and from the orders table, I want to pick order id. 

1715
01:54:16,000 --> 01:54:20,000
Now finally, let's sort the results so we can clearly see what 

1716
01:54:20,000 --> 01:54:24,000
we get. So order by c.customer 

1717
01:54:24,000 --> 01:54:28,000
id. Let's execute that query and see what we get. 

1718
01:54:28,000 --> 01:54:32,000
So, here' the result. For customer number 2 called 

1719
01:54:32,000 --> 01:54:36,000
inis or inis whatever, you have 2 orders, order 4, 

1720
01:54:36,000 --> 01:54:40,000
and order 7. Similarly for customer number 5, we have 

1721
01:54:40,000 --> 01:54:44,000
2 orders and so on. Now there is something missing in this result. 

1722
01:54:44,000 --> 01:54:48,000
We only see customers who have an order in our system, these are 

1723
01:54:48,000 --> 01:54:52,000
customers 2, 5, 6, 7, 8, and 10. But

1724
01:54:52,000 --> 01:54:56,000
if you look at the customers table, you can see that 

1725
01:54:56,000 --> 01:55:00,000
you have other customers like customer number 10, customers number 3, and so on. 

1726
01:55:00,000 --> 01:55:04,000
Currently we don't have any orders for these customers, and that's the reason 

1727
01:55:04,000 --> 01:55:08,000
we don't see them in this results set. But what if you want to see all the 

1728
01:55:08,000 --> 01:55:12,000
customers whether they have an order or not? That's when we use an 

1729
01:55:12,000 --> 01:55:16,000
outer join. Let me show you how that works. So back to our query 

1730
01:55:16,000 --> 01:55:20,000
the reason we only saw customers who have an order was because 

1731
01:55:20,000 --> 01:55:24,000
of this join condition, When joining these two tables, you are only 

1732
01:55:24,000 --> 01:55:28,000
returning records that match his condition. So for a

1733
01:55:28,000 --> 01:55:32,000
given customer, if we do have an order, that record

1734
01:55:32,000 --> 01:55:36,000
is returned. But as you saw a second ago, some customers don't have 

1735
01:55:36,000 --> 01:55:40,000
an order. So for those customers this condition is not 

1736
01:55:40,000 --> 01:55:44,000
valid. And that is the reason they are not returned in the result set. 

1737
01:55:44,000 --> 01:55:48,000
To solve this problem we use an outer join. Now in SQL we 

1738
01:55:48,000 --> 01:55:52,000
have two types of outer joins. We have left joins and right 

1739
01:55:52,000 --> 01:55:56,000
joins. When we use a left join, 

1740
01:55:56,000 --> 01:56:00,000
all the records from the left table, in this case customers are 

1741
01:56:00,000 --> 01:56:04,000
returned whether this condition is true or not. So we 

1742
01:56:04,000 --> 01:56:08,000
get all the customers, and if they do have an order, we'll see the order id 

1743
01:56:08,000 --> 01:56:12,000
as well. Let's execute this query and see what we get. So, 

1744
01:56:12,000 --> 01:56:16,000
there you go. Customer number 1, 

1745
01:56:16,000 --> 01:56:20,000
doesn't have an order and that's why we get null in this cell. 

1746
01:56:20,000 --> 01:56:24,000
Customer number 2 has two orders, 4, and 7, customer 

1747
01:56:24,000 --> 01:56:28,000
number 3 also doesn't have an order so we get null for order id. 

1748
01:56:28,000 --> 01:56:32,000
This is the result of a left join. So back to our query 

1749
01:56:32,000 --> 01:56:36,000
when we use a left join, all the records from the left 

1750
01:56:36,000 --> 01:56:40,000
table are returned whether this condition is true or not. 

1751
01:56:40,000 --> 01:56:44,000
Now what if we use a right join. In this 

1752
01:56:44,000 --> 01:56:48,000
case, all the records from the orders table are returned whether this condition is 

1753
01:56:48,000 --> 01:56:52,000
true or not. Let's execute this query and see what we get. 

1754
01:56:52,000 --> 01:56:56,000
So, we get he same result as before. 

1755
01:56:56,000 --> 01:57:00,000
when we use an inner join, because we are selecting all the records from the right table 

1756
01:57:00,000 --> 01:57:04,000
which is the orders table, so we don't see all the customers 

1757
01:57:04,000 --> 01:57:08,000
we see all the orders. Now if you want to use a right join, and 

1758
01:57:08,000 --> 01:57:12,000
still see all the customers, you need to swap the order of these tables. So, 

1759
01:57:12,000 --> 01:57:16,000
we put the orders table first that's going to be our left table. 

1760
01:57:16,000 --> 01:57:20,000
And then, we put the customers on the right side, 

1761
01:57:20,000 --> 01:57:24,000
so now with this query we'll return all the records from the right table 

1762
01:57:24,000 --> 01:57:28,000
which is the customers table. We execute this we get 

1763
01:57:28,000 --> 01:57:32,000
all the customers whether they have an order or not. 

1764
01:57:32,000 --> 01:57:36,000
Beautiful. Now one last thing before we finish this tutorial, 

1765
01:57:36,000 --> 01:57:40,000
I've seen developers use the outer keyword here. So either 

1766
01:57:40,000 --> 01:57:44,000
right outer join or left outer join. But technically 

1767
01:57:44,000 --> 01:57:48,000
the outer keyword is optional just like the inner keyword, so you don't have to type it out. 

1768
01:57:48,000 --> 01:57:52,000
So I'm going to remove this to make this code shorter and easier to 

1769
01:57:52,000 --> 01:57:56,000
understand. So to recap, if you have the join keyword directly, and 

1770
01:57:56,000 --> 01:58:00,000
if you do a left or right join you're doing a 

1771
01:58:00,000 --> 01:58:04,000
inner outer join. 

1772
01:58:04,000 --> 01:58:08,000
Here's your exercise for this tutorial. I want you

1773
01:58:08,000 --> 01:58:12,000
to write a query that produces this result. So we should have three columns here. Product 

1774
01:58:12,000 --> 01:58:16,000
ID, name, and quantity that I picked from the 

1775
01:58:16,000 --> 01:58:20,000
order items table, so here we need to join the products table. 

1776
01:58:20,000 --> 01:58:24,000
With order items table. So we can see how many times each product is ordered. 

1777
01:58:24,000 --> 01:58:28,000
However, in an inner join we will only see the products that 

1778
01:58:28,000 --> 01:58:32,000
have an order, but here I'm doing an outer join, so, 

1779
01:58:32,000 --> 01:58:36,000
product number 7, has never been ordered, but still exists in the result. 

1780
01:58:36,000 --> 01:58:40,000
Is it null, or the quantity? So go ahead and write an outer 

1781
01:58:40,000 --> 01:58:44,000
join, or use this result. 

1782
01:58:44,000 --> 01:58:48,000
Alright, first we select 

1783
01:58:48,000 --> 01:58:52,000
everything from the products table and then 

1784
01:58:52,000 --> 01:58:56,000
to a left join with the order items table. 

1785
01:58:56,000 --> 01:59:00,000
Our join condition is p.product 

1786
01:59:00,000 --> 01:59:04,000
id equals oi.product id. 

1787
01:59:04,000 --> 01:59:08,000
So because we'll get all the products 

1788
01:59:08,000 --> 01:59:12,000
in the products table whether this condition is true or not. If you have never 

1789
01:59:12,000 --> 01:59:16,000
been ordered, you still see them in the result. Now, let's 

1790
01:59:16,000 --> 01:59:20,000
pick a few columns for clarity. So p.productid 

1791
01:59:20,000 --> 01:59:24,000
p.name and oi.

1792
01:59:24,000 --> 01:59:28,000
quantity. That's it. Let's execute the query.

1793
01:59:28,000 --> 01:59:32,000
We get the same result as before. So all the products are here. 

1794
01:59:32,000 --> 01:59:36,000
And product number 7 has never been ordered so we see 

1795
01:59:36,000 --> 01:59:40,000
null for the quantity. 

1796
01:59:40,000 --> 01:59:44,000
Similar 

1797
01:59:44,000 --> 01:59:48,000
to inner joins, we can use outer joins between multiple tables. Let me show

1798
01:59:48,000 --> 01:59:52,000
you. So here's the query that we wrote in the last tutorial, you are doing a 

1799
01:59:52,000 --> 01:59:56,000
left join between customers and orders tables. 

1800
01:59:56,000 --> 02:00:00,000
So when we execute this query, you get all the customer 

1801
02:00:00,000 --> 02:00:04,000
whether they have an order or not. If you have an order you see

1802
02:00:04,000 --> 02:00:08,000
the order id. Beautiful. Now if you look at the orders

1803
02:00:08,000 --> 02:00:12,000
table, you can see that some of our orders have a

1804
02:00:12,000 --> 02:00:16,000
shipper id. These are the orders that have been shipped. So now let's join 

1805
02:00:16,000 --> 02:00:20,000
orders table with the shippers table to display the name of the shipper in the result. 

1806
02:00:20,000 --> 02:00:24,000
So back to our query, after this left join, 

1807
02:00:24,000 --> 02:00:28,000
let's write another join, here I'm doing an inner join. 

1808
02:00:28,000 --> 02:00:32,000
So let's inner join the orders table with the shippers table. 

1809
02:00:32,000 --> 02:00:36,000
Join shippers, we call it sh, on 

1810
02:00:36,000 --> 02:00:40,000
what is the join condition. Well, oh.shipper 

1811
02:00:40,000 --> 02:00:44,000
id, should be equal to sh.shipper 

1812
02:00:44,000 --> 02:00:48,000
id. Alright? So in this query we have 

1813
02:00:48,000 --> 02:00:52,000
a left outer join and inner join. Let's see 

1814
02:00:52,000 --> 02:00:56,000
what we get, alright, we only 

1815
02:00:56,000 --> 02:01:00,000
see 5 records. But you have more orders. So here you have the same problem 

1816
02:01:00,000 --> 02:01:04,000
we have before. Some of our orders don't have a shipper, and that is why 

1817
02:01:04,000 --> 02:01:08,000
they are not returned here. In other words, this join condition

1818
02:01:08,000 --> 02:01:12,000
is not true, for some of our orders. So back to the orders table, 

1819
02:01:12,000 --> 02:01:16,000
a an example, this first order doesn't have a shipper

1820
02:01:16,000 --> 02:01:20,000
shipper id is null, and that is why it is not returned with a query result. 

1821
02:01:20,000 --> 02:01:24,000
So to solve this problem, you should use a left join, you want to make sure

1822
02:01:24,000 --> 02:01:28,000
that all orders are returned whether they have a shipper or not. 

1823
02:01:28,000 --> 02:01:32,000
So back to the query, you need to replace this inner join 

1824
02:01:32,000 --> 02:01:36,000
with the left join, so let's execute the query and see what happens. 

1825
02:01:36,000 --> 02:01:40,000
Now we should have quite a few more orders, there

1826
02:01:40,000 --> 02:01:44,000
you go, now to make this example more interesting, I'm going to add the ship

1827
02:01:44,000 --> 02:01:48,000
-per name here. So back to our select

1828
02:01:48,000 --> 02:01:52,000
boss, let's add a new column, shipper.name. 

1829
02:01:52,000 --> 02:01:56,000
Now we can give it an alias like shipper

1830
02:01:56,000 --> 02:02:00,000
let's execute the query and here's the result.

1831
02:02:00,000 --> 02:02:04,000
So we get all the customers whether they have an order or 

1832
02:02:04,000 --> 02:02:08,000
not. And for those who do have an order, we get all the orders

1833
02:02:08,000 --> 02:02:12,000
whether we have a shipper or not. This is the power

1834
02:02:12,000 --> 02:02:16,000
of outer joins. Now in the last tutorial, you learned that you can get the

1835
02:02:16,000 --> 02:02:20,000
same result, in both the left join or the right join, you just have to

1836
02:02:20,000 --> 02:02:24,000
swap the order of the tables. However, as a best practice of what

1837
02:02:24,000 --> 02:02:28,000
to avoid using right joins, because when you're joining multiple tables and you have 

1838
02:02:28,000 --> 02:02:32,000
left and right and inner join, things get really complex. So, 

1839
02:02:32,000 --> 02:02:36,000
someone else reading your code, will have difficulty visualizing how you're joining these tables. 

1840
02:02:36,000 --> 02:02:40,000
As an example, if you have a right join here and then a left join 

1841
02:02:40,000 --> 02:02:44,000
after, it will be harder to visualize how these tables are getting joined. 

1842
02:02:44,000 --> 02:02:48,000
So, as a best practice, avoid right joins, and use left joins 

1843
02:02:48,000 --> 02:02:52,000
instead. 

1844
02:02:52,000 --> 02:02:56,000
And, here is your exercise for this tutorial. 

1845
02:02:56,000 --> 02:03:00,000
I want you to write a query that produces this result. So here you have these columns 

1846
02:03:00,000 --> 02:03:04,000
order date, order id, the first name of the customer

1847
02:03:04,000 --> 02:03:08,000
the shipper and we can see that some of our orders are not shipped yet. 

1848
02:03:08,000 --> 02:03:12,000
So here we have null, and here finally, we have the status. 

1849
02:03:12,000 --> 02:03:16,000
So go ahead, spend 2-3 minutes on this exercise, when you're done continue 

1850
02:03:16,000 --> 02:03:20,000
watching. 

1851
02:03:20,000 --> 02:03:24,000
Alright, let's select everything 

1852
02:03:24,000 --> 02:03:28,000
from the orders table, now you should join this with

1853
02:03:28,000 --> 02:03:32,000
customers, on, hold.customerid. 

1854
02:03:32,000 --> 02:03:36,000
Should be equal to c.customer id. Here I'm using

1855
02:03:36,000 --> 02:03:40,000
an inner join, because every order does have a customer. So, 

1856
02:03:40,000 --> 02:03:44,000
this condition is always valid, it doesn't matter if we use a left join or a 

1857
02:03:44,000 --> 02:03:48,000
inner join here, now, okay? Now before going any further let's 

1858
02:03:48,000 --> 02:03:52,000
take our columns. So from the orders table, I'm going to pick order id. 

1859
02:03:52,000 --> 02:03:56,000
Followed by order date. And then, 

1860
02:03:56,000 --> 02:04:00,000
customer.firstname. 

1861
02:04:00,000 --> 02:04:04,000
Which we can optionally rename to customer. 

1862
02:04:04,000 --> 02:04:08,000
Alright, next we need to select the shipper. So, we

1863
02:04:08,000 --> 02:04:12,000
join the result with the shippers table, 

1864
02:04:12,000 --> 02:04:16,000
on order.shipperid equal 

1865
02:04:16,000 --> 02:04:20,000
to shipper.shipperid. However, if we use an inner join here,

1866
02:04:20,000 --> 02:04:24,000
because some of our orders don't have a shipper, we are only 

1867
02:04:24,000 --> 02:04:28,000
going to see the orders that have been shipped. Let me show you. So, 

1868
02:04:28,000 --> 02:04:32,000
for clarity, I'm going to add the shippers name here, so shipper

1869
02:04:32,000 --> 02:04:36,000
.name as shipper. Let's execute the query 

1870
02:04:36,000 --> 02:04:40,000
there you go, we only see the orders that have been shipped. 

1871
02:04:40,000 --> 02:04:44,000
But we want to see all the orders, right? So, we need to 

1872
02:04:44,000 --> 02:04:48,000
change the second joint to a left join. 

1873
02:04:48,000 --> 02:04:52,000
So all orders are returned whether they have a shipper or not. 

1874
02:04:52,000 --> 02:04:56,000
Let's execute the query one more time, 

1875
02:04:56,000 --> 02:05:00,000
there you go. Now we see all the orders from number 1-10. 

1876
02:05:00,000 --> 02:05:04,000
Beautiful. Finally, we need to add the status comment here. 

1877
02:05:04,000 --> 02:05:08,000
So, we need to do another join here, join

1878
02:05:08,000 --> 02:05:12,000
with order status's, which we aggregate 

1879
02:05:12,000 --> 02:05:16,000
as os, on oh.status equals 

1880
02:05:16,000 --> 02:05:20,000
to os.orderstatusid. 

1881
02:05:20,000 --> 02:05:24,000
We can see that I have designed our database such that sometimes our column names 

1882
02:05:24,000 --> 02:05:28,000
are exactly identical, but in other cases they don't match. 

1883
02:05:28,000 --> 02:05:32,000
So in order table we call this column, status, as opposed to 

1884
02:05:32,000 --> 02:05:36,000
order status id, and this is deliberate because a lot of 

1885
02:05:36,000 --> 02:05:40,000
real databases are like that. Alright, now let's add

1886
02:05:40,000 --> 02:05:44,000
the status name here, so order, status.name as

1887
02:05:44,000 --> 02:05:48,000
status. Execute the query, 

1888
02:05:48,000 --> 02:05:52,000
and we can see all the orders here, 

1889
02:05:52,000 --> 02:05:56,000
for each order we have the data, the customer, the supper and the status. 

1890
02:05:56,000 --> 02:06:00,000


1891
02:06:00,000 --> 02:06:04,000
Earlier, we talked about self joins in

1892
02:06:04,000 --> 02:06:08,000
SQL. So here in the SQLhr database, we have this

1893
02:06:08,000 --> 02:06:12,000
employees table, we rote a query to get 

1894
02:06:12,000 --> 02:06:16,000
all the employees and their manager. So here we have this column, reports 

1895
02:06:16,000 --> 02:06:20,000
to that specifies the manager for each employee. So let's go back

1896
02:06:20,000 --> 02:06:24,000
and rewrite this query to get all the employees and their manager. 

1897
02:06:24,000 --> 02:06:28,000
Back to our query editor window, first let's use

1898
02:06:28,000 --> 02:06:32,000
a SQL hr database. Then select everything 

1899
02:06:32,000 --> 02:06:36,000
from the employees table,

1900
02:06:36,000 --> 02:06:40,000
we give it an alias and then join it with itself. 

1901
02:06:40,000 --> 02:06:44,000
So this is what we call a self join. Now we're going to use a different alias 

1902
02:06:44,000 --> 02:06:48,000
like m for managers. Now, what

1903
02:06:48,000 --> 02:06:52,000
is the joint condition e.reports to, should be equal to 

1904
02:06:52,000 --> 02:06:56,000
m.employee ID, right? 

1905
02:06:56,000 --> 02:07:00,000
Now for clarity, let's pick only three columns, so either the id 

1906
02:07:00,000 --> 02:07:04,000
employee.first name. 

1907
02:07:04,000 --> 02:07:08,000
And m.firstname which we rename to 

1908
02:07:08,000 --> 02:07:12,000
manager. Alright, let's execute this query and see what we get. 

1909
02:07:12,000 --> 02:07:16,000
So, here's the result 

1910
02:07:16,000 --> 02:07:20,000
as you can see all these employees have the same manager. 

1911
02:07:20,000 --> 02:07:24,000
However, there is something missing here. We don't have a record for this person, this 

1912
02:07:24,000 --> 02:07:28,000
manager himself. So what is missing is a record where 

1913
02:07:28,000 --> 02:07:32,000
we can see the employee id for this person, their name and their 

1914
02:07:32,000 --> 02:07:36,000
manager which should be null because this person is the CEO or the 

1915
02:07:36,000 --> 02:07:40,000
head of the company. But why is this happening? The reason is, 

1916
02:07:40,000 --> 02:07:44,000
our inner join, because this condition we have here will only 

1917
02:07:44,000 --> 02:07:48,000
return people who have manager. We can solve this problem by using a 

1918
02:07:48,000 --> 02:07:52,000
left join. So, we do a left join, because we want to get every

1919
02:07:52,000 --> 02:07:56,000
employee in this table whether they have a manager or not. 

1920
02:07:56,000 --> 02:08:00,000
Okay, now let's execute the query one more time. 

1921
02:08:00,000 --> 02:08:04,000
There you go. Now we have a record for this person 

1922
02:08:04,000 --> 02:08:08,000
the manager, as you can see this person does not have a manger, that's why

1923
02:08:08,000 --> 02:08:12,000
we have null here. 

1924
02:08:12,000 --> 02:08:16,000
Back to our SQL store database 

1925
02:08:16,000 --> 02:08:20,000
here we have a simple query that joins the orders table, 

1926
02:08:20,000 --> 02:08:24,000
with a customers table. And here's our join condition. We have several examples 

1927
02:08:24,000 --> 02:08:28,000
of this before. Now as our queries get more complex 

1928
02:08:28,000 --> 02:08:32,000
these joint conditions get in the way, they make our queries hard to read, but the good news 

1929
02:08:32,000 --> 02:08:36,000
is that in MySQL, we have a powerful feature for simplifying 

1930
02:08:36,000 --> 02:08:40,000
these queries. If the column name is exactly the same 

1931
02:08:40,000 --> 02:08:44,000
across these two tables, we can replace the on clause. 

1932
02:08:44,000 --> 02:08:48,000
With a using clause which is simpler and shorter. 

1933
02:08:48,000 --> 02:08:52,000
So I'm going to comment out this line and instead type out using 

1934
02:08:52,000 --> 02:08:56,000
in parenthesis, we type out the column name, that is custom. 

1935
02:08:56,000 --> 02:09:00,000
customer id. What we have in line 7 is exactly identical to what we have 

1936
02:09:00,000 --> 02:09:04,000
on line 6. That is shorter and easier to read. So, 

1937
02:09:04,000 --> 02:09:08,000
let me delete this line. We can add another join

1938
02:09:08,000 --> 02:09:12,000
statement here to join the orders for the shippers here, so join with 

1939
02:09:12,000 --> 02:09:16,000
shippers using 

1940
02:09:16,000 --> 02:09:20,000
shipper id. In both these tables we have a column with the exact 

1941
02:09:20,000 --> 02:09:24,000
same name. Alright, now let's execute this query 

1942
02:09:24,000 --> 02:09:28,000
this is what we get, you have the order id followed by the 

1943
02:09:28,000 --> 02:09:32,000
first name of the customer. Let's add a new column here, 

1944
02:09:32,000 --> 02:09:36,000
so, I'm going to add sh 

1945
02:09:36,000 --> 02:09:40,000
.name that is the name of the shipper, 

1946
02:09:40,000 --> 02:09:44,000
now obviously because some of our orders are not shipped, we have to replace this 

1947
02:09:44,000 --> 02:09:48,000
inner join to the left join. So we can

1948
02:09:48,000 --> 02:09:52,000
use the using keyword with both inner and outer joins. Let's execute 

1949
02:09:52,000 --> 02:09:56,000
the query one more time. There you go. 

1950
02:09:56,000 --> 02:10:00,000
Now, we have the name of the shipper next to each order, beautiful, 

1951
02:10:00,000 --> 02:10:04,000
however, we cannot use this technique to join the result with the 

1952
02:10:04,000 --> 02:10:08,000
order status's table. Because in the orders table we have 

1953
02:10:08,000 --> 02:10:12,000
this column called status, but in order status's table, this column has a different 

1954
02:10:12,000 --> 02:10:16,000
name. It's order status id. Let me show you. So, 

1955
02:10:16,000 --> 02:10:20,000
order status's. columns, there you go, order status id. 

1956
02:10:20,000 --> 02:10:24,000
So the using keyword only works if the column name is 

1957
02:10:24,000 --> 02:10:28,000
exactly the same across different tables. Now what if we have multiple 

1958
02:10:28,000 --> 02:10:32,000
columns in our join condition. For example, earlier we talked about 

1959
02:10:32,000 --> 02:10:36,000
tis order items table, I told you that in this table we have 

1960
02:10:36,000 --> 02:10:40,000
a composite primary key, which basically means a primary key that consists 

1961
02:10:40,000 --> 02:10:44,000
of multiple columns. So the combination of these two columns uniquely 

1962
02:10:44,000 --> 02:10:48,000
identifies each record in this table. Now if I join this table, 

1963
02:10:48,000 --> 02:10:52,000
with order item notes table. In our join 

1964
02:10:52,000 --> 02:10:56,000
join condition, we should compare both these columns with their corresponding 

1965
02:10:56,000 --> 02:11:00,000
columns in the order item notes table. So let's quickly 

1966
02:11:00,000 --> 02:11:04,000
write that query and then simplify it with the using keyword. 

1967
02:11:04,000 --> 02:11:08,000
So, select everything from 

1968
02:11:08,000 --> 02:11:12,000
order items, now, join it with order 

1969
02:11:12,000 --> 02:11:16,000
item notes on 

1970
02:11:16,000 --> 02:11:20,000
so here we need to compare oi.order 

1971
02:11:20,000 --> 02:11:24,000
id with yn.orderid, and 

1972
02:11:24,000 --> 02:11:28,000
oi.productid=

1973
02:11:28,000 --> 02:11:32,000
to oin.productid. This join 

1974
02:11:32,000 --> 02:11:36,000
condition is kind of messy, it's hard to read this query. Now let's

1975
02:11:36,000 --> 02:11:40,000
simplify this query with the using keyword. So we type out using. In parenthesis 

1976
02:11:40,000 --> 02:11:44,000
we add both columns and then separate them using a comma. 

1977
02:11:44,000 --> 02:11:48,000
So, ordered and product 

1978
02:11:48,000 --> 02:11:52,000
id. Isn't that better? 

1979
02:11:52,000 --> 02:11:56,000
Now, for our exercise, back to our

1980
02:11:56,000 --> 02:12:00,000
SQL invoicing database write a query to select the payment 

1981
02:12:00,000 --> 02:12:04,000
from the payments table and produce something like this. So in this table we have the date 

1982
02:12:04,000 --> 02:12:08,000
the client, the amount and the payment method, we can see. 

1983
02:12:08,000 --> 02:12:12,000
On what date who has paid how much using what payment method. 

1984
02:12:12,000 --> 02:12:16,000


1985
02:12:16,000 --> 02:12:20,000
Alright, I'm going to use the SQL

1986
02:12:20,000 --> 02:12:24,000
invoicing database, and then select everything from the 

1987
02:12:24,000 --> 02:12:28,000
payments table, join it with the clients table. 

1988
02:12:28,000 --> 02:12:32,000
Using client id because in 

1989
02:12:32,000 --> 02:12:36,000
both these tables, you have the client id table. Next we need to join this with 

1990
02:12:36,000 --> 02:12:40,000
payment methods, however, they 

1991
02:12:40,000 --> 02:12:44,000
column name between these two tables is different, so in the payment 

1992
02:12:44,000 --> 02:12:48,000
table we have a column called payment method. But in payment 

1993
02:12:48,000 --> 02:12:52,000
methods table, our column is called payment method ID. So here we 

1994
02:12:52,000 --> 02:12:56,000
cannot use the using keyword, and we'll have to use

1995
02:12:56,000 --> 02:13:00,000
the on clause. So on p.payment 

1996
02:13:00,000 --> 02:13:04,000
underline method equals pm. 

1997
02:13:04,000 --> 02:13:08,000
paymentmethodid. Now let's pick our columns. 

1998
02:13:08,000 --> 02:13:12,000
So, payment.date client.name. 

1999
02:13:12,000 --> 02:13:16,000
And we rename this as client, next we pick

2000
02:13:16,000 --> 02:13:20,000
m out, and finally, the payment method, 

2001
02:13:20,000 --> 02:13:24,000
so, let's rename that to payment_method 

2002
02:13:24,000 --> 02:13:28,000
and execute the query, there we go, this is what we get. 

2003
02:13:28,000 --> 02:13:32,000
The date, the client, the amount, and the payment method. 

2004
02:13:32,000 --> 02:13:36,000


2005
02:13:36,000 --> 02:13:40,000
In MySQL, we also have another 

2006
02:13:40,000 --> 02:13:44,000
simpler way, to join two tales, it's called a natural join, and it's

2007
02:13:44,000 --> 02:13:48,000
easier to code, but it's not something to recommend, because sometimes it produces unexpected

2008
02:13:48,000 --> 02:13:52,000
results. But let me quickly show you how it works in case you see it somewhere

2009
02:13:52,000 --> 02:13:56,000
so at least you're familiar with it. So back to the previous example, 

2010
02:13:56,000 --> 02:14:00,000
let's select everything from the orders table, that

2011
02:14:00,000 --> 02:14:04,000
we should do a natural join with the customer's table. 

2012
02:14:04,000 --> 02:14:08,000
Now with this natural join, we don't exactly specify the column name. 

2013
02:14:08,000 --> 02:14:12,000
So the database engine will look at these two tables and it will join 

2014
02:14:12,000 --> 02:14:16,000
them based on the common columns. The columns don't have the same 

2015
02:14:16,000 --> 02:14:20,000
name. And that is the reason this query is shorted right. 

2016
02:14:20,000 --> 02:14:24,000
So, for clarity, let's pick a couple of columns here, o.order 

2017
02:14:24,000 --> 02:14:28,000
id and c. let's say first name. 

2018
02:14:28,000 --> 02:14:32,000
Let's execute the query, there you go. 

2019
02:14:32,000 --> 02:14:36,000
so we see all the orders and the customers replace them. 

2020
02:14:36,000 --> 02:14:40,000
So natural joins are really easy to code but they can 

2021
02:14:40,000 --> 02:14:44,000
be a little bit dangerous, because we're letting the database engine 

2022
02:14:44,000 --> 02:14:48,000
guess the join, you don't have control over it. For this very reason, 

2023
02:14:48,000 --> 02:14:52,000
natural joins can produce unexpected results, and that's why

2024
02:14:52,000 --> 02:14:56,000
I discourage you to use them. 

2025
02:14:56,000 --> 02:15:00,000
In this tutorial, 

2026
02:15:00,000 --> 02:15:04,000
were going to look at cross joins in SQL. We use cross joins to

2027
02:15:04,000 --> 02:15:08,000
mine or join every record from the first table, with every record, 

2028
02:15:08,000 --> 02:15:12,000
in a second table. Here is an example, let's select 

2029
02:15:12,000 --> 02:15:16,000
everything from the customers table to 

2030
02:15:16,000 --> 02:15:20,000
now here we do a cross join with the products table. 

2031
02:15:20,000 --> 02:15:24,000
So every record in the customers table, will be combined with 

2032
02:15:24,000 --> 02:15:28,000
every record in the products table. And that is why we don't have 

2033
02:15:28,000 --> 02:15:32,000
a condition here. Okay? So this is what we call a cross join 

2034
02:15:32,000 --> 02:15:36,000
now for clarity let's pick a couple of columns like

2035
02:15:36,000 --> 02:15:40,000
see that first name we rename it as customer

2036
02:15:40,000 --> 02:15:44,000
and then product.name which we rename to 

2037
02:15:44,000 --> 02:15:48,000
product. Also, let's sort the result 

2038
02:15:48,000 --> 02:15:52,000
by customer. first name. 

2039
02:15:52,000 --> 02:15:56,000
Now, let's execute the query, here's the result of the cross join, 

2040
02:15:56,000 --> 02:16:00,000
so first we have amber as the customer, and here are all

2041
02:16:00,000 --> 02:16:04,000
combinations of amber with different products. 

2042
02:16:04,000 --> 02:16:08,000
Next we have Barbara or whatever it is, and again we have the combination of this custom 

2043
02:16:08,000 --> 02:16:12,000
with all the products. Now in this particular example, it doesn't really make

2044
02:16:12,000 --> 02:16:16,000
sense to use a cross join, a real example for using 

2045
02:16:16,000 --> 02:16:20,000
cross join is where you have a table of sizes like small, 

2046
02:16:20,000 --> 02:16:24,000
medium, large, and a table of colors, like red, blue, green whatever. 

2047
02:16:24,000 --> 02:16:28,000
And then you want to combine all the sizes with all the 

2048
02:16:28,000 --> 02:16:32,000
colors. That is when you use a cross join. 

2049
02:16:32,000 --> 02:16:36,000
Wha we have here is called the explicit syntax for cross join, you also

2050
02:16:36,000 --> 02:16:40,000
have the implicit syntax which looks like this. Instead of typing out

2051
02:16:40,000 --> 02:16:44,000
the cross join, you type out multiple tables in the 

2052
02:16:44,000 --> 02:16:48,000
from clause. So customers and orders. 

2053
02:16:48,000 --> 02:16:52,000
Both these queries produce the same result. But I personally prefer to use 

2054
02:16:52,000 --> 02:16:56,000
the explicit syntax because it's more clear. 

2055
02:16:56,000 --> 02:17:00,000


2056
02:17:00,000 --> 02:17:04,000
And here's a simple exercise for you. Do a cross join between shippers and 

2057
02:17:04,000 --> 02:17:08,000
products. First do it using the implicit syntax, 

2058
02:17:08,000 --> 02:17:12,000
and then using the explicit syntax. It's pretty straight forward, I just want you to 

2059
02:17:12,000 --> 02:17:16,000
get your hands dirty in the code and get used to this syntax. 

2060
02:17:16,000 --> 02:17:20,000


2061
02:17:20,000 --> 02:17:24,000
Alright, first I'm going to use the explicit syntax, and then I'm going to

2062
02:17:24,000 --> 02:17:28,000
place the syntax. So let's start by selecting everything from 

2063
02:17:28,000 --> 02:17:32,000
2 tables, shippers and products, 

2064
02:17:32,000 --> 02:17:36,000
now for clarity I'm going to pick two columns, shipper.

2065
02:17:36,000 --> 02:17:40,000
name which we rename to the shipper. And product.name which we 

2066
02:17:40,000 --> 02:17:44,000
order everything by 

2067
02:17:44,000 --> 02:17:48,000
shipper

2068
02:17:48,000 --> 02:17:52,000
Let's execute the query, this is what we get. So the combination of all shippers

2069
02:17:52,000 --> 02:17:56,000
and all products beautiful,  now let's use the 

2070
02:17:56,000 --> 02:18:00,000
explicit syntax, so we select everything from the base table, 

2071
02:18:00,000 --> 02:18:04,000
in this case shippers and then do a cross join with products. 

2072
02:18:04,000 --> 02:18:08,000
That produces the same exact result. 

2073
02:18:08,000 --> 02:18:12,000


2074
02:18:12,000 --> 02:18:16,000
We covered everything about joins, you learned 

2075
02:18:16,000 --> 02:18:20,000
that with joins we can combine columns with multiple tables, but 

2076
02:18:20,000 --> 02:18:24,000
in SQL we can also combine rows with multiple tables, and this

2077
02:18:24,000 --> 02:18:28,000
is extremely powerful. And let me show you how this works. First we have 

2078
02:18:28,000 --> 02:18:32,000
a quick look at our orders table, and select everything from the order 

2079
02:18:32,000 --> 02:18:36,000
table. Now if you look at the data, 

2080
02:18:36,000 --> 02:18:40,000
we can see that the first order was placed in the current year, 

2081
02:18:40,000 --> 02:18:44,000
2019, all the other orders were placed in previous years. Now

2082
02:18:44,000 --> 02:18:48,000
let's say you want to create a report, get all the orders, and next to each order, 

2083
02:18:48,000 --> 02:18:52,000
add a label. If the order is placed in the current year, the table is 

2084
02:18:52,000 --> 02:18:56,000
going to be active, and if the order is placed in previous years, you want to label it 

2085
02:18:56,000 --> 02:19:00,000
as archives. So, let's change our 

2086
02:19:00,000 --> 02:19:04,000
query and change our condition here. First you want to get all

2087
02:19:04,000 --> 02:19:08,000
the orders in the current year. So where order 

2088
02:19:08,000 --> 02:19:12,000
date is greater than or equal to 2019, 

2089
02:19:12,000 --> 02:19:16,000
0101. Now I just want to highlight that this is 

2090
02:19:16,000 --> 02:19:20,000
not the ideal way to get the orders in the current year, because here we have hard 

2091
02:19:20,000 --> 02:19:24,000
coded 2019. So if you execute this query next year, we are not 

2092
02:19:24,000 --> 02:19:28,000
going to get the right result. But don't worry about this for now. Later in the course I will show you how to 

2093
02:19:28,000 --> 02:19:32,000
get the orders in the current year, without hard coding a date here. 

2094
02:19:32,000 --> 02:19:36,000
So, let's execute this query, now we get 

2095
02:19:36,000 --> 02:19:40,000
only one order. Let's hand pick a couple of columns here. 

2096
02:19:40,000 --> 02:19:44,000
So, order id, 

2097
02:19:44,000 --> 02:19:48,000
and order date. And also I want to add a string, 

2098
02:19:48,000 --> 02:19:52,000
literal here, like active. Right? 

2099
02:19:52,000 --> 02:19:56,000
Let's execute this query, this is what we get. We get 3 

2100
02:19:56,000 --> 02:20:00,000
columns, order id, order date, and active, and in this column, 

2101
02:20:00,000 --> 02:20:04,000
argument we have this string value. Active. Now let's

2102
02:20:04,000 --> 02:20:08,000
rename this column to status, alright?

2103
02:20:08,000 --> 02:20:12,000
And execute the query, that is better, 

2104
02:20:12,000 --> 02:20:16,000
now we want to write another query similar to this that will return the order 

2105
02:20:16,000 --> 02:20:20,000
in the previous year, but with a different label, archive. 

2106
02:20:20,000 --> 02:20:24,000
So, to save time, I'm going to copy this

2107
02:20:24,000 --> 02:20:28,000
few lines and paste them right after our first

2108
02:20:28,000 --> 02:20:32,000
select statement. Now note that here we have a syntax error, because we didn't 

2109
02:20:32,000 --> 02:20:36,000
terminate the first select statement with a semi colon, but don't

2110
02:20:36,000 --> 02:20:40,000
worry about it, we're going to get back to this in a second so for the second 

2111
02:20:40,000 --> 02:20:44,000
query, we want to return a different a different label, archive, and we want 

2112
02:20:44,000 --> 02:20:48,000
to change our condition to less then 

2113
02:20:48,000 --> 02:20:52,000
2019. Now, select only these few lines. 

2114
02:20:52,000 --> 02:20:56,000
And execute this query, either by clicking on this icon here, 

2115
02:20:56,000 --> 02:21:00,000
or using the keyword shortcut you learned earlier in the course. 

2116
02:21:00,000 --> 02:21:04,000
There you go, here are all the 

2117
02:21:04,000 --> 02:21:08,000
orders from the previous year, with the label archive. 

2118
02:21:08,000 --> 02:21:12,000
This query returns 9 records. The previous query returned 1 record. 

2119
02:21:12,000 --> 02:21:16,000
now using the union operator we can combine data from

2120
02:21:16,000 --> 02:21:20,000
these two queries, so, in between 

2121
02:21:20,000 --> 02:21:24,000
our select statement we type out union 

2122
02:21:24,000 --> 02:21:28,000
now let's execute the query one more time, so here's our first 

2123
02:21:28,000 --> 02:21:32,000
order in the current year that is active and below that we have 

2124
02:21:32,000 --> 02:21:36,000
the orders in the previous years. So using the union operator we can combine

2125
02:21:36,000 --> 02:21:40,000
records for multiple queries. Now in this example, both our queries are

2126
02:21:40,000 --> 02:21:44,000
against the same table, but we can also have queries against different 

2127
02:21:44,000 --> 02:21:48,000
tables and then combine the result into one result set. 

2128
02:21:48,000 --> 02:21:52,000
Let me show you another example. So I'm going to delete everything here.

2129
02:21:52,000 --> 02:21:56,000
Let's select the first name, 

2130
02:21:56,000 --> 02:22:00,000
from the customers table, and then we can union that with select 

2131
02:22:00,000 --> 02:22:04,000
the name from the shippers table. 

2132
02:22:04,000 --> 02:22:08,000
Let's execute the query's in one result set

2133
02:22:08,000 --> 02:22:12,000
we can see all the customers and the shippers. Now as far as 

2134
02:22:12,000 --> 02:22:16,000
I know, there is no real world care for this particular query. But what I

2135
02:22:16,000 --> 02:22:20,000
Want to point out is that with union we can combine results from multiple 

2136
02:22:20,000 --> 02:22:24,000
query's. These query's can be against the same table or different 

2137
02:22:24,000 --> 02:22:28,000
tables. In your database, you can have a table like archive

2138
02:22:28,000 --> 02:22:32,000
orders, and another table like order 

2139
02:22:32,000 --> 02:22:36,000
and then you could combine all the archive and active orders into one 

2140
02:22:36,000 --> 02:22:40,000
result set. Just remember, that the number of columns that the query 

2141
02:22:40,000 --> 02:22:44,000
returns should be equal, otherwise you're going to get an error. For example, 

2142
02:22:44,000 --> 02:22:48,000
let's select the first name and last name from customers 

2143
02:22:48,000 --> 02:22:52,000
and then union that with the name of 

2144
02:22:52,000 --> 02:22:56,000
shippers. When we execute this query, we get an error, because the first part 

2145
02:22:56,000 --> 02:23:00,000
of this query returns two columns, but the second part returns one column. 

2146
02:23:00,000 --> 02:23:04,000
So MySQL doesn't know how to combine these records. 

2147
02:23:04,000 --> 02:23:08,000
And one last thing before we finish this tutorial. If you look at the result here, 

2148
02:23:08,000 --> 02:23:12,000
the name of this column is based on this

2149
02:23:12,000 --> 02:23:16,000
first query, so the first query returns first name, and that's why this column is called 

2150
02:23:16,000 --> 02:23:20,000
first name. If you change the order of these queries, 

2151
02:23:20,000 --> 02:23:24,000
and move this union up here, now let's run this query 

2152
02:23:24,000 --> 02:23:28,000
as you can see our column is called name. 

2153
02:23:28,000 --> 02:23:32,000
So whatever we have in this first query is used to determine the name of 

2154
02:23:32,000 --> 02:23:36,000
columns. Here we can also rename the column to full name. 

2155
02:23:36,000 --> 02:23:40,000
There you go. 

2156
02:23:40,000 --> 02:23:44,000


2157
02:23:44,000 --> 02:23:48,000
Here's your exercise for this tutorial. Write a query for this report. 

2158
02:23:48,000 --> 02:23:52,000
So here we have four columns, customer ID, points, and 

2159
02:23:52,000 --> 02:23:56,000
title. Now as you know we don't have this column in the customers table, 

2160
02:23:56,000 --> 02:24:00,000
so we have calculated the values of this column, based on 

2161
02:24:00,000 --> 02:24:04,000
the points each customer had. If they have less then 2,000 points, 

2162
02:24:04,000 --> 02:24:08,000
their type is bronze. If they have between 2,000 and 

2163
02:24:08,000 --> 02:24:12,000
3,000 points they are silver customers, and if they have more then 

2164
02:24:12,000 --> 02:24:16,000
3,000 points, they are gold customers. Also note that here we have sort 

2165
02:24:16,000 --> 02:24:20,000
the result by the first name. So go ahead and spend

2166
02:24:20,000 --> 02:24:24,000
two minutes to write this query. 

2167
02:24:24,000 --> 02:24:28,000
Alright, first let's get the bronze customers, 

2168
02:24:28,000 --> 02:24:32,000
so select everything from customers where 

2169
02:24:32,000 --> 02:24:36,000
points is less then 2,000. 

2170
02:24:36,000 --> 02:24:40,000
Now here we want to pick 3 columns, customer id, 

2171
02:24:40,000 --> 02:24:44,000
first name, end points. And finally we 

2172
02:24:44,000 --> 02:24:48,000
add a new column to a string literal, bronze 

2173
02:24:48,000 --> 02:24:52,000
let's run this query and see what we get. So these are all the bronze 

2174
02:24:52,000 --> 02:24:56,000
customers, but the name of this column in bronze, we don't want that.

2175
02:24:56,000 --> 02:25:00,000
So, let's rename this to type. Now this is off the screen so 

2176
02:25:00,000 --> 02:25:04,000
I'm going to break this up into multiple lines 

2177
02:25:04,000 --> 02:25:08,000
that makers our query bigger and easier to read. 

2178
02:25:08,000 --> 02:25:12,000
There you go, let's run the query one more time, now the column is called type. 

2179
02:25:12,000 --> 02:25:16,000
Beautiful. Now we should do union 

2180
02:25:16,000 --> 02:25:20,000
and repeat this query, but extract the silver customers. 

2181
02:25:20,000 --> 02:25:24,000
So I'm going to paste this query here and then make a 

2182
02:25:24,000 --> 02:25:28,000
couple of changes here, I'm going to replace bronze with silver, 

2183
02:25:28,000 --> 02:25:32,000
and change the condition to between 2,000 

2184
02:25:32,000 --> 02:25:36,000
and 3,000 let's run our query, see what we get 

2185
02:25:36,000 --> 02:25:40,000
so, we have all the bronze customers first, 

2186
02:25:40,000 --> 02:25:44,000
followed by all the silver customers. So the order of these records is based 

2187
02:25:44,000 --> 02:25:48,000
on our queries. In our first query we got the bronze customers, which is why 

2188
02:25:48,000 --> 02:25:52,000
they are listed first. But this is not what we want. You want 

2189
02:25:52,000 --> 02:25:56,000
to order the result by the first name of our customers. So, 

2190
02:25:56,000 --> 02:26:00,000
let's apply an order by at the end

2191
02:26:00,000 --> 02:26:04,000
so order by first name. Now there is one more piece remaining. 

2192
02:26:04,000 --> 02:26:08,000
You should do a union one more time and write a query to get 

2193
02:26:08,000 --> 02:26:12,000
the gold customers. SO I'm going to select these few lines. 

2194
02:26:12,000 --> 02:26:16,000
And paste them here. 

2195
02:26:16,000 --> 02:26:20,000
Now let's change silver to gold, 

2196
02:26:20,000 --> 02:26:24,000
and the condition to (?) greater then 3000. 

2197
02:26:24,000 --> 02:26:28,000
And finally we do an imported by. Let's run the query one more time. 

2198
02:26:28,000 --> 02:26:32,000
And here's the end result, our customers 

2199
02:26:32,000 --> 02:26:36,000
are sorted by first name, bronze, silver and

2200
02:26:36,000 --> 02:26:40,000
gold customers. 

2201
02:26:40,000 --> 02:26:44,000
In this section I'm going to teach you how

2202
02:26:44,000 --> 02:26:48,000
to insert, update, and delete data. Before we get started 

2203
02:26:48,000 --> 02:26:52,000
let's have a closer look at our customers table. So click on 

2204
02:26:52,000 --> 02:26:56,000
this middle icon to open this table in the design mode. 

2205
02:26:56,000 --> 02:27:00,000
What you see here might look a little bit intimidating at first, but trust me 

2206
02:27:00,000 --> 02:27:04,000
it's so easy, and in this tutorial, I'm going to explain exactly what we have in

2207
02:27:04,000 --> 02:27:08,000
these columns. So on the left side, you can see the column 

2208
02:27:08,000 --> 02:27:12,000
next to that you can see the data type for each column, so our customer id column 

2209
02:27:12,000 --> 02:27:16,000
can only accept integer value. Integers are whole numbers

2210
02:27:16,000 --> 02:27:20,000
like 1234 and so on. You don't have decimal points, etc. 

2211
02:27:20,000 --> 02:27:24,000
First thing is a var chart which is short for variable 

2212
02:27:24,000 --> 02:27:28,000
character. And in parenthesis, you can see 50, that basically 

2213
02:27:28,000 --> 02:27:32,000
means in this column you can have a maximum 

2214
02:27:32,000 --> 02:27:36,000
of characters now if the name of a customer is only 5 characters long the only 

2215
02:27:36,000 --> 02:27:40,000
store those 5 characters. So even though the max 

2216
02:27:40,000 --> 02:27:44,000
length for this column is 50, you're not going to waste the space if this customer 

2217
02:27:44,000 --> 02:27:48,000
name is less then 50 characters. That is why here we have 

2218
02:27:48,000 --> 02:27:52,000
4char which is short for variable. In contrast we have 

2219
02:27:52,000 --> 02:27:56,000
another data type that is character. If you had character 50 here, 

2220
02:27:56,000 --> 02:28:00,000
and the name of the customer was only 5 characters long, MySQL 

2221
02:28:00,000 --> 02:28:04,000
will insert additional 45 spaces to fill this column. 

2222
02:28:04,000 --> 02:28:08,000
So this is a waste of space. So as a best practice, 

2223
02:28:08,000 --> 02:28:12,000
Most oft he type we use var char to store strings 

2224
02:28:12,000 --> 02:28:16,000
or textural values. Now here on the right side we have this column 

2225
02:28:16,000 --> 02:28:20,000
pk, which is short for primary key. So customer 

2226
02:28:20,000 --> 02:28:24,000
id is marked as the primary key, and that is why we have this yellow key here, 

2227
02:28:24,000 --> 02:28:28,000
so the values in this column uniquely identify each 

2228
02:28:28,000 --> 02:28:32,000
customer. Next to that we have nn which is short for not null

2229
02:28:32,000 --> 02:28:36,000
and that determines if this column can except null values or not. 

2230
02:28:36,000 --> 02:28:40,000
In this case, every customer record, must have the customer id. 

2231
02:28:40,000 --> 02:28:44,000
First name, last name, as well as these other attributes. 

2232
02:28:44,000 --> 02:28:48,000
But birthdays and phone are optional. So in these columns we 

2233
02:28:48,000 --> 02:28:52,000
can have null values, Now we have another calling here, ai, 

2234
02:28:52,000 --> 02:28:56,000
which is short for auto increment and this is often used 

2235
02:28:56,000 --> 02:29:00,000
with primary key columns, so every time we insert a new 

2236
02:29:00,000 --> 02:29:04,000
record in this table, we let MySQL or our database engine insert 

2237
02:29:04,000 --> 02:29:08,000
a value in this column, so essentially it gets the customer id 

2238
02:29:08,000 --> 02:29:12,000
for the last row, and it will increment it by 1, by the time

2239
02:29:12,000 --> 02:29:16,000
you serve a new record. So if you look at the data you can 

2240
02:29:16,000 --> 02:29:20,000
see that currently we only have 10 customers here. So if you have a new customer here, 

2241
02:29:20,000 --> 02:29:24,000
MySQL will sign 11 to the new customer, okay?

2242
02:29:24,000 --> 02:29:28,000
And finally here we have another column that specifies 

2243
02:29:28,000 --> 02:29:32,000
the default value for each column. For example, for birthday 

2244
02:29:32,000 --> 02:29:36,000
and phone columns, the default values or null, 

2245
02:29:36,000 --> 02:29:40,000
So if you don't supply a value MySQL will supply the null values 

2246
02:29:40,000 --> 02:29:44,000
for these columns. Similarly we have another null value, 

2247
02:29:44,000 --> 02:29:48,000
for the points column, so if we don't supply the points for a customer, MySQL

2248
02:29:48,000 --> 02:29:52,000
will use 0, now we have a few other columns here which are not important 

2249
02:29:52,000 --> 02:29:56,000
at this stage, you will learn about them later in this course. So now 

2250
02:29:56,000 --> 02:30:00,000
you understand the attribute of each column, let's go ahead 

2251
02:30:00,000 --> 02:30:04,000
and insert data into this table. 

2252
02:30:04,000 --> 02:30:08,000
In this tutorial, 

2253
02:30:08,000 --> 02:30:12,000
you're going to learn how to insert a row into a table. For that we're going to use 

2254
02:30:12,000 --> 02:30:16,000
the insert into statement. Where are we going to 

2255
02:30:16,000 --> 02:30:20,000
insert this row? Into the customers table, so we type out 

2256
02:30:20,000 --> 02:30:24,000
the name of the table here followed by the values clause. 

2257
02:30:24,000 --> 02:30:28,000
And here in parenthesis we supply the values for every 

2258
02:30:28,000 --> 02:30:32,000
column in this table, so back to our table definition, 

2259
02:30:32,000 --> 02:30:36,000
these are all the columns, first we need to supply a value for the customer id 

2260
02:30:36,000 --> 02:30:40,000
column. However, in this column, the auto increment 

2261
02:30:40,000 --> 02:30:44,000
attribute is enabled, and as I told you before, if we don't supply a value, 

2262
02:30:44,000 --> 02:30:48,000
MySQL will generate a unique value for us. 

2263
02:30:48,000 --> 02:30:52,000
So we can go back to our statement and either assign 

2264
02:30:52,000 --> 02:30:56,000
an explicit value or use default to let MySQL 

2265
02:30:56,000 --> 02:31:00,000
take care of generating this value. This is the preferred approach. Because if we use this value 

2266
02:31:00,000 --> 02:31:04,000
an explicit value like 200 it is possible that you might have 

2267
02:31:04,000 --> 02:31:08,000
another customer with the same id. So when you execute the statement, you're going to get an error. 

2268
02:31:08,000 --> 02:31:12,000
Because you cannot have duplicate values in this column. Every value

2269
02:31:12,000 --> 02:31:16,000
should be unique, so here we're going to use the default keyword to let you generate

2270
02:31:16,000 --> 02:31:20,000
a unique value for the customer id, and after that we need to 

2271
02:31:20,000 --> 02:31:24,000
supply a value or the first name and last name columns. 

2272
02:31:24,000 --> 02:31:28,000
So, let's say Jon Smith. 

2273
02:31:28,000 --> 02:31:32,000
Note that I have enclosed these values with quotes, because as I have told you, 

2274
02:31:32,000 --> 02:31:36,000
string and for in SQL, we should always enclose string and

2275
02:31:36,000 --> 02:31:40,000
values with quotes. Either single or double quotes, okay? 

2276
02:31:40,000 --> 02:31:44,000
Now, what else? Back to our customer table, 

2277
02:31:44,000 --> 02:31:48,000
after the last name you have birthdate, however, 

2278
02:31:48,000 --> 02:31:52,000
as we can see, this column is optional because this check box is not checked. So 

2279
02:31:52,000 --> 02:31:56,000
here we can use null or an explicit value. Null means the absence 

2280
02:31:56,000 --> 02:32:00,000
of a value. So back t our statement, you can type out 

2281
02:32:00,000 --> 02:32:04,000
the birthdate, like 1990 January 1st or 

2282
02:32:04,000 --> 02:32:08,000
you can use the null keyword to leave out this value. 

2283
02:32:08,000 --> 02:32:12,000
Now in this demo, I'm going to use a value date, 

2284
02:32:12,000 --> 02:32:16,000
now to make this code cleaner and more readable, I'm going to break it up into 

2285
02:32:16,000 --> 02:32:20,000
multiple lines. That's better, 

2286
02:32:20,000 --> 02:32:24,000
now back to our table, next we have phone and phone is 

2287
02:32:24,000 --> 02:32:28,000
also optional, because this checkboxes not checked, and null is the 

2288
02:32:28,000 --> 02:32:32,000
default value for this column. So here we can explicitly pass 

2289
02:32:32,000 --> 02:32:36,000
null, or use the default keyword and then put null into this 

2290
02:32:36,000 --> 02:32:40,000
column. It's exactly the same. So, back to our 

2291
02:32:40,000 --> 02:32:44,000
statement, you can pass null or default. 

2292
02:32:44,000 --> 02:32:48,000
Both these keywords will have the same result. In this case I'm going to use the null 

2293
02:32:48,000 --> 02:32:52,000
keyword. Alright, let's have one more look at our table, 

2294
02:32:52,000 --> 02:32:56,000
next we have 4 more columns that are 

2295
02:32:56,000 --> 02:33:00,000
required, so address, city, state, and points. And note that points 

2296
02:33:00,000 --> 02:33:04,000
has the default value of 0, so we can either use an explicit value like 

2297
02:33:04,000 --> 02:33:08,000
total value like 200, or use the default keyword and let MySQL generate

2298
02:33:08,000 --> 02:33:12,000
0. So, back to our statement, let's type out 

2299
02:33:12,000 --> 02:33:16,000
an address, it doesn't really matter. 

2300
02:33:16,000 --> 02:33:20,000
Followed by a city, and a state, let's say california, 

2301
02:33:20,000 --> 02:33:24,000
and finally points, again we use explicit value 

2302
02:33:24,000 --> 02:33:28,000
or default, so this is how we can insert a row into 

2303
02:33:28,000 --> 02:33:32,000
a table. However, in this example, you're only 

2304
02:33:32,000 --> 02:33:36,000
supplying values for first name, last name, birthdate and 

2305
02:33:36,000 --> 02:33:40,000
these address fields. So you're leaving out phone number 

2306
02:33:40,000 --> 02:33:44,000
the customer id and the points. So there's another way 

2307
02:33:44,000 --> 02:33:48,000
to write the statement. Let me show you. So after the table name you can 

2308
02:33:48,000 --> 02:33:52,000
optionally supply the stuff columns that you want 

2309
02:33:52,000 --> 02:33:56,000
to insert values into. In this case first name, 

2310
02:33:56,000 --> 02:34:00,000
last name, birthdate 

2311
02:34:00,000 --> 02:34:04,000
and once again I'm going to break up this statement into multiple lines 

2312
02:34:04,000 --> 02:34:08,000
So 3 more columns, 

2313
02:34:08,000 --> 02:34:12,000
address, city, and state, 

2314
02:34:12,000 --> 02:34:16,000
so these are the 6 columns that we're going to supply values

2315
02:34:16,000 --> 02:34:20,000
for. With this change, we don't have to use these default 

2316
02:34:20,000 --> 02:34:24,000
or null values, we only supply values for these columns. 

2317
02:34:24,000 --> 02:34:28,000
So I'm going to remove default from here, and null, and finally 

2318
02:34:28,000 --> 02:34:32,000
this last default keyword. 

2319
02:34:32,000 --> 02:34:36,000
So, the 6 values that you supplied here are used for the 6th column. 

2320
02:34:36,000 --> 02:34:40,000
Now with this change, you can also reorder the columns. 

2321
02:34:40,000 --> 02:34:44,000
We don't have to list them in the same order, they were defined 

2322
02:34:44,000 --> 02:34:48,000
in the customers table, for example you can put the last name first, 

2323
02:34:48,000 --> 02:34:52,000
and then obviously we should also swap the order of these values, 

2324
02:34:52,000 --> 02:34:56,000
so we can list them in any orders. Now we can execute 

2325
02:34:56,000 --> 02:35:00,000
the statement, now if you look at the output window 

2326
02:35:00,000 --> 02:35:04,000
down on the bottom you should see the statement followed by one rows 

2327
02:35:04,000 --> 02:35:08,000
unfortunately I cannot resize this window to show you this message, but if you look down

2328
02:35:08,000 --> 02:35:12,000
below you can see that one word was affected, which basically means 

2329
02:35:12,000 --> 02:35:16,000
one record was inserted into this table. Now, 

2330
02:35:16,000 --> 02:35:20,000
let's look at the data in the customers table 

2331
02:35:20,000 --> 02:35:24,000
so the last row is the one that we inserted, we can see that the 

2332
02:35:24,000 --> 02:35:28,000
MySQL automatically generated the value 11, this is the effect 

2333
02:35:28,000 --> 02:35:32,000
of auto increment attribute. So it takes the value of the last row, 

2334
02:35:32,000 --> 02:35:36,000
and incrememnts it by 1. So here we have the first name. Last name, 

2335
02:35:36,000 --> 02:35:40,000
birthdate, you didn't supply a value for the phone attribute, so, 

2336
02:35:40,000 --> 02:35:44,000
that's why we have null here, we also have address, city 

2337
02:35:44,000 --> 02:35:48,000
state, and the default value of 0 for the points. 

2338
02:35:48,000 --> 02:35:52,000


2339
02:35:52,000 --> 02:35:56,000
In this tutorial, you're going to learn how to 

2340
02:35:56,000 --> 02:36:00,000
insert multiple rows in one go. For this we're going to use the shippers 

2341
02:36:00,000 --> 02:36:04,000
table, let's have a quick look at the table definition 

2342
02:36:04,000 --> 02:36:08,000
so here we have 2 columns, shipper id and name. Shipper id is 

2343
02:36:08,000 --> 02:36:12,000
primary key, it's not nullable, and it's an auto incremented 

2344
02:36:12,000 --> 02:36:16,000
column. So we're going to let MySQL generate values for this column. Easy. 

2345
02:36:16,000 --> 02:36:20,000
You only need to supply a value for the name column. So back to our 

2346
02:36:20,000 --> 02:36:24,000
query editor window, we type out insert 

2347
02:36:24,000 --> 02:36:28,000
into shippers in parenthesis we specify the name of the column 

2348
02:36:28,000 --> 02:36:32,000
we want to insert values into, in this case name 

2349
02:36:32,000 --> 02:36:36,000
followed by the values clause. Here we add a pair of 

2350
02:36:36,000 --> 02:36:40,000
parenthesis with a value like shipper one. Now

2351
02:36:40,000 --> 02:36:44,000
insert multiple rows all you have to do is insert a comma 

2352
02:36:44,000 --> 02:36:48,000
followed by another pair of parenthesis. So, 

2353
02:36:48,000 --> 02:36:52,000
shipper 2, one more time, comma, shipper 3, 

2354
02:36:52,000 --> 02:36:56,000
this is how you can insert multiple rows in 1 row, 

2355
02:36:56,000 --> 02:37:00,000
now let's execute this statement, alright, 

2356
02:37:00,000 --> 02:37:04,000
and then inspect the data in the shippers data. 

2357
02:37:04,000 --> 02:37:08,000
There you go. So initially we only had

2358
02:37:08,000 --> 02:37:12,000
5 shippers and here are the 3 new shippers that we inserted. Note that MySQL 

2359
02:37:12,000 --> 02:37:16,000
automatically generated the values for the shipper id column. 

2360
02:37:16,000 --> 02:37:20,000
So we have 67 and 8. 

2361
02:37:20,000 --> 02:37:24,000
Alright, here's your exercise

2362
02:37:24,000 --> 02:37:28,000
for this tutorial. Write a statement to insert three rows 

2363
02:37:28,000 --> 02:37:32,000
in the products table, it's really easy you can knock it out in a minute, 

2364
02:37:32,000 --> 02:37:36,000


2365
02:37:36,000 --> 02:37:40,000
So here's our products table, we only have 4 columns, 

2366
02:37:40,000 --> 02:37:44,000
we're going to leave out the first column because it's an auto increments  column 

2367
02:37:44,000 --> 02:37:48,000
so we only have to supply values for name, quality, unit price. 

2368
02:37:48,000 --> 02:37:52,000
Back to our query editor window, let's insert 

2369
02:37:52,000 --> 02:37:56,000
into products the columns are 

2370
02:37:56,000 --> 02:38:00,000
name, quanitty in stock, and unit 

2371
02:38:00,000 --> 02:38:04,000
price. And the values are going to be let's say product 1, 

2372
02:38:04,000 --> 02:38:08,000
stock is going to be 10 and the unit price is going to be 1, 

2373
02:38:08,000 --> 02:38:12,000
.95. Now I'm going to select these values.

2374
02:38:12,000 --> 02:38:16,000
copy, paste it, like this, 

2375
02:38:16,000 --> 02:38:20,000
change the values accordingly, and 

2376
02:38:20,000 --> 02:38:24,000
finally the last row for the 3 

2377
02:38:24,000 --> 02:38:28,000
there you go, let's execute this statement, alright 

2378
02:38:28,000 --> 02:38:32,000
and then verify the result so

2379
02:38:32,000 --> 02:38:36,000
in the products table, now we should have 3 new records, 

2380
02:38:36,000 --> 02:38:40,000
now the id's you see here are 15, 16, and 17. 

2381
02:38:40,000 --> 02:38:44,000
Because before recording this video I actually inserted a few records in this table and then 

2382
02:38:44,000 --> 02:38:48,000
deleted them. So I had product ID's 11, 12

2383
02:38:48,000 --> 02:38:52,000
13, and 14. And even though they're actually deleted from 

2384
02:38:52,000 --> 02:38:56,000
this table, MySQL remembers their id's so instead of incrementing 

2385
02:38:56,000 --> 02:39:00,000
10 x 11, it incremented 14 which is the last record 

2386
02:39:00,000 --> 02:39:04,000
from before. And that's why you generated 15. On your computer, 

2387
02:39:04,000 --> 02:39:08,000
the items are going to be 11, 12, 13. 

2388
02:39:08,000 --> 02:39:12,000


2389
02:39:12,000 --> 02:39:16,000
So far you have only learned how to insert data into a singular table. 

2390
02:39:16,000 --> 02:39:20,000
In this tutorial, I'm going to show you how to insert data into multiple tables. Here's 

2391
02:39:20,000 --> 02:39:24,000
a really good example, look at the orders table, what columns do we have? 

2392
02:39:24,000 --> 02:39:28,000
We have the order id, we have the customer 

2393
02:39:28,000 --> 02:39:32,000
id, so we know who has placed the order, we know the date of the order, 

2394
02:39:32,000 --> 02:39:36,000
you know the status, comments, as well as shipping 

2395
02:39:36,000 --> 02:39:40,000
information, but the actual items for this order are not in this table, they 

2396
02:39:40,000 --> 02:39:44,000
are in the order items table. So in this table, we have 4 columns 

2397
02:39:44,000 --> 02:39:48,000
we have the order id, so we know what order these items 

2398
02:39:48,000 --> 02:39:52,000
for. We have the product id, so we know what product 

2399
02:39:52,000 --> 02:39:56,000
order, in what quantity, and in what price. So an actual 

2400
02:39:56,000 --> 02:40:00,000
order can have 1 or more order items. 

2401
02:40:00,000 --> 02:40:04,000
This is what we call a parent child relationship. So this relationship 

2402
02:40:04,000 --> 02:40:08,000
the orders table is the parent, and the order items table is the 

2403
02:40:08,000 --> 02:40:12,000
child. So one row in the orders table can have 1 or more children 

2404
02:40:12,000 --> 02:40:16,000
inside the order items table. Now in this tutorial, I'm going to show you 

2405
02:40:16,000 --> 02:40:20,000
how to insert an order and all it's items. So you will learn 

2406
02:40:20,000 --> 02:40:24,000
how to insert data into multiple cables. alright, back 

2407
02:40:24,000 --> 02:40:28,000
to our query editor window. First we need to insert the order, 

2408
02:40:28,000 --> 02:40:32,000
so insert, into, let me close 

2409
02:40:32,000 --> 02:40:36,000
the navigator panel, we want to insert a record into the order 

2410
02:40:36,000 --> 02:40:40,000
table, now what columns do we have here?

2411
02:40:40,000 --> 02:40:44,000
So we have these columns but only the first four are the 

2412
02:40:44,000 --> 02:40:48,000
and actually the first one, we don't want to worry about, because that's an auto increment column. 

2413
02:40:48,000 --> 02:40:52,000
So we only want to supply values for customer id, order date, 

2414
02:40:52,000 --> 02:40:56,000
and status. So back to our query, specifying those

2415
02:40:56,000 --> 02:41:00,000
columns here, customer id, order date, 

2416
02:41:00,000 --> 02:41:04,000
and status, now let's supply the value. 

2417
02:41:04,000 --> 02:41:08,000
In the customer id column, we need to add a 

2418
02:41:08,000 --> 02:41:12,000
valid customer id. So let's have a quick look at our customers 

2419
02:41:12,000 --> 02:41:16,000
table, there you go. In this table, 

2420
02:41:16,000 --> 02:41:20,000
we have 11 records. So these are the valid customer id's. 

2421
02:41:20,000 --> 02:41:24,000
Now back to our query, let's use 1 for customer query 

2422
02:41:24,000 --> 02:41:28,000
and then 2019, January the 2nd 

2423
02:41:28,000 --> 02:41:32,000
for the order date, and one for the order status, once again 

2424
02:41:32,000 --> 02:41:36,000
in this column, we need to insert a valid order status 

2425
02:41:36,000 --> 02:41:40,000
id. If you don't supply a valid id, MySQL is going to get

2426
02:41:40,000 --> 02:41:44,000
ahead of us. So we insert an order here, 

2427
02:41:44,000 --> 02:41:48,000
the items, now back to our order items table, 

2428
02:41:48,000 --> 02:41:52,000
in this table, we have this order id column, so here's the 

2429
02:41:52,000 --> 02:41:56,000
as soon as we insert an order, MySQL is going to generate 

2430
02:41:56,000 --> 02:42:00,000
an id for our new order now we need to access that id in 

2431
02:42:00,000 --> 02:42:04,000
order to insert the items in this table. How can we do that? 

2432
02:42:04,000 --> 02:42:08,000
Well, back to our query editor window, 

2433
02:42:08,000 --> 02:42:12,000
in MySQL, we have a bunch of built in functions, and a function 

2434
02:42:12,000 --> 02:42:16,000
is basically a piece of code that we use ourself. Just like a function is a feature 

2435
02:42:16,000 --> 02:42:20,000
in your tv. Every tv comes with a bunch of functions like 

2436
02:42:20,000 --> 02:42:24,000
power on, power off, change the volume, change the channel so on. 

2437
02:42:24,000 --> 02:42:28,000
So MySQL and other database engines come with a  bunch of built in functions 

2438
02:42:28,000 --> 02:42:32,000
that we can use in our programs. One of these funcitons

2439
02:42:32,000 --> 02:42:36,000
is last insert id. We can call or 

2440
02:42:36,000 --> 02:42:40,000
execute this function, by adding parenthesis here, and this will return the ID 

2441
02:42:40,000 --> 02:42:44,000
that MySQL generates when we insert a new row. 

2442
02:42:44,000 --> 02:42:48,000
So, before going any further, let's just select these, 

2443
02:42:48,000 --> 02:42:52,000
and make sure you get the right result. Now we have a syntax error here because we didn't terminate 

2444
02:42:52,000 --> 02:42:56,000
the first statement with a semi colon, alright, now let's execute this query, 

2445
02:42:56,000 --> 02:43:00,000
alright, so the id of the new order is 

2446
02:43:00,000 --> 02:43:04,000
12. Let's verify that. So back to the orders 

2447
02:43:04,000 --> 02:43:08,000
table let's look at the data. On my machine I have 

2448
02:43:08,000 --> 02:43:12,000
12 records here, I actually created 1 just before recording this video, so on your 

2449
02:43:12,000 --> 02:43:16,000
machine you're going to have 11 orders. 

2450
02:43:16,000 --> 02:43:20,000
Now back to our query window now that we know how to  get the id of the newly inserted 

2451
02:43:20,000 --> 02:43:24,000
record, we can use that id to insert the child records. 

2452
02:43:24,000 --> 02:43:28,000
So, we're going to write another insert statement, 

2453
02:43:28,000 --> 02:43:32,000
insert into order items, let's have 

2454
02:43:32,000 --> 02:43:36,000
another look at the columns in this table. So we have 4 columns 

2455
02:43:36,000 --> 02:43:40,000
on all of them are required, so there's really no need to specify the column name 

2456
02:43:40,000 --> 02:43:44,000
in our insert statement, you simply supply values or order id, 

2457
02:43:44,000 --> 02:43:48,000
product id, quantity and unit price. So, here 

2458
02:43:48,000 --> 02:43:52,000
in the values clause, we add parenthesis, 

2459
02:43:52,000 --> 02:43:56,000
what is our order id? That is the value returned 

2460
02:43:56,000 --> 02:44:00,000
from calling this function. So I'm going to cut this from here and 

2461
02:44:00,000 --> 02:44:04,000
next we need to supply a valid photo id, 

2462
02:44:04,000 --> 02:44:08,000
but let's say product 1, quantity, let's say 1. 

2463
02:44:08,000 --> 02:44:12,000
And the unit price 2.95 dollars. 

2464
02:44:12,000 --> 02:44:16,000
Now let's delete this select we don't really need it anymore 

2465
02:44:16,000 --> 02:44:20,000
let's add another set of values, so once again, we're going to call

2466
02:44:20,000 --> 02:44:24,000
last insert id, to get the id of a new order, we're going to 

2467
02:44:24,000 --> 02:44:28,000
change the product to product number 2, and add a different price. 

2468
02:44:28,000 --> 02:44:32,000
That's it. Now let's execute this 

2469
02:44:32,000 --> 02:44:36,000
statement and see what we get. Alright, so, 

2470
02:44:36,000 --> 02:44:40,000
back to our orders table, let's refresh the records here, alright 

2471
02:44:40,000 --> 02:44:44,000
so we have a new order, order number 13, 

2472
02:44:44,000 --> 02:44:48,000
beautiful, now let's look at the orders items table, here's the order

2473
02:44:48,000 --> 02:44:52,000
items, let's open the table. So we should have 

2474
02:44:52,000 --> 02:44:56,000
2 items, or order number 13. Beautiful. 

2475
02:44:56,000 --> 02:45:00,000
So this is how you insert hierarchical data in SQL. 

2476
02:45:00,000 --> 02:45:04,000


2477
02:45:04,000 --> 02:45:08,000
In this tutorial, I'm going to show you how to copy data from one 

2478
02:45:08,000 --> 02:45:12,000
table to another. For example, in our orders table, currently we have 

2479
02:45:12,000 --> 02:45:16,000
about a dozen records. Now let's say we want to create a copy of this table 

2480
02:45:16,000 --> 02:45:20,000
called orders archive and you want to insert every row that we have 

2481
02:45:20,000 --> 02:45:24,000
in this table into that new table. If you have 10 orders, 

2482
02:45:24,000 --> 02:45:28,000
we don't want to quote an insert statement with a ten set of values, 

2483
02:45:28,000 --> 02:45:32,000
that is very time consuming, so I want to show you a powerful technique to 

2484
02:45:32,000 --> 02:45:36,000
uniquely copy data from one table to another. First we need to create this new table, order 

2485
02:45:36,000 --> 02:45:40,000
archive. For that we're going to use the create 

2486
02:45:40,000 --> 02:45:44,000
table as statement. So create table 

2487
02:45:44,000 --> 02:45:48,000
orders archive as. 

2488
02:45:48,000 --> 02:45:52,000
Now right after that we write a select statement 

2489
02:45:52,000 --> 02:45:56,000
to get everything from the orders table. 

2490
02:45:56,000 --> 02:46:00,000
Now let's see what happens when we execute this query, there you go.

2491
02:46:00,000 --> 02:46:04,000
So back in the navigator panel, we have to refresh this view

2492
02:46:04,000 --> 02:46:08,000
by clicking on this icon over here, now we 

2493
02:46:08,000 --> 02:46:12,000
have a new table, orders archive, let's look at the data, 

2494
02:46:12,000 --> 02:46:16,000
so you can see all the orders are here and we have the exact same column 

2495
02:46:16,000 --> 02:46:20,000
as the orders table. However, if you open this table in the 

2496
02:46:20,000 --> 02:46:24,000
design mode, you cans ee that in this table, we don't have a primary key. 

2497
02:46:24,000 --> 02:46:28,000
So the order id column is not marked as a primary key. 

2498
02:46:28,000 --> 02:46:32,000
And also it's not marked as an auto increment column, so when we create a table

2499
02:46:32,000 --> 02:46:36,000
using this technique MySQl will ignore these attributes, 

2500
02:46:36,000 --> 02:46:40,000
and that means if you want to explicitly insert the record 

2501
02:46:40,000 --> 02:46:44,000
into this new table, you have to supply a value for order id, 

2502
02:46:44,000 --> 02:46:48,000
because this column is no longer an auto increment column. 

2503
02:46:48,000 --> 02:46:52,000
So, using create table as statement you can quickly create 

2504
02:46:52,000 --> 02:46:56,000
a copy of a table, now we refer to this select statement 

2505
02:46:56,000 --> 02:47:00,000
as a sub query, so a subquery is a select statement 

2506
02:47:00,000 --> 02:47:04,000
that is part of another SQL statement. 

2507
02:47:04,000 --> 02:47:08,000
Now we can also use a sub query and an insert statement and that is a very

2508
02:47:08,000 --> 02:47:12,000
powerful technique. It allows us to do really cool things. Let me show you. 

2509
02:47:12,000 --> 02:47:16,000
So first, let's right click the orders archive table, 

2510
02:47:16,000 --> 02:47:20,000
and click on truncate table, because we want to delete 

2511
02:47:20,000 --> 02:47:24,000
all the data in this table. Alright, it's asking for confirmation 

2512
02:47:24,000 --> 02:47:28,000
let's truncate the table, so now back to this table. 

2513
02:47:28,000 --> 02:47:32,000
Let's refresh the table, we don't have any records here, alright? 

2514
02:47:32,000 --> 02:47:36,000
Now back to our query editor, let's say you want to copy 

2515
02:47:36,000 --> 02:47:40,000
only a subset of records from the orders table into this table, 

2516
02:47:40,000 --> 02:47:44,000
like all the orders placed before 2019. So first let's select 

2517
02:47:44,000 --> 02:47:48,000
everything from the orders table where 

2518
02:47:48,000 --> 02:47:52,000
order date is less then 2019, January 1st. 

2519
02:47:52,000 --> 02:47:56,000
So, these are all the orders, order

2520
02:47:56,000 --> 02:48:00,000
s

2521
02:48:00,000 --> 02:48:04,000
copy these orders into he orders archive table. So

2522
02:48:04,000 --> 02:48:08,000
we can use this select statement as a subquery  

2523
02:48:08,000 --> 02:48:12,000
in an insert statement, we write insert 

2524
02:48:12,000 --> 02:48:16,000
into orders archive 

2525
02:48:16,000 --> 02:48:20,000
now we don't need to supply the column names, because we're going to 

2526
02:48:20,000 --> 02:48:24,000
play values for every column that we have in this query. 

2527
02:48:24,000 --> 02:48:28,000
So, we did that, and 

2528
02:48:28,000 --> 02:48:32,000
this is ane xample of using a select statement as a subquery 

2529
02:48:32,000 --> 02:48:36,000
in an insert statement. Let's execute this, 

2530
02:48:36,000 --> 02:48:40,000
alright, now back to the table, let's refresh the records 

2531
02:48:40,000 --> 02:48:44,000
we only have the orders placed before 2019. 

2532
02:48:44,000 --> 02:48:48,000


2533
02:48:48,000 --> 02:48:52,000
Alright, here's a really, really, really coo exercise 

2534
02:48:52,000 --> 02:48:56,000
back to our SQL invoicing database. Look at the invoices table. 

2535
02:48:56,000 --> 02:49:00,000
So in this table, we have these columns, 

2536
02:49:00,000 --> 02:49:04,000
(?) id number, client id number which is associated or related 

2537
02:49:04,000 --> 02:49:08,000
to the client id column, in the clients table, followed by 

2538
02:49:08,000 --> 02:49:12,000
a few other columns, now let's say you want to create a copy of the record 

2539
02:49:12,000 --> 02:49:16,000
in this table, and put them in a new table called invoices archive. 

2540
02:49:16,000 --> 02:49:20,000
However in that table, instead of the client id

2541
02:49:20,000 --> 02:49:24,000
column, we want to have the client name column, so you want to join 

2542
02:49:24,000 --> 02:49:28,000
table with the clients table, and then use that query as a sub query in a create table statement. 

2543
02:49:28,000 --> 02:49:32,000
Also, to mae the exercise more interesting, 

2544
02:49:32,000 --> 02:49:36,000
I want you to copy only the invoices that do have a payment. So if 

2545
02:49:36,000 --> 02:49:40,000
you look over here, this payment data column here, determines 

2546
02:49:40,000 --> 02:49:44,000
if a payment has been made, towards this invoice or not. So select 

2547
02:49:44,000 --> 02:49:48,000
only the invoices that do have a payment date, it's a really really good 

2548
02:49:48,000 --> 02:49:52,000
exercise, spend two to three minutes on this and then come back and continue watching. 

2549
02:49:52,000 --> 02:49:56,000


2550
02:49:56,000 --> 02:50:00,000
Alright, first I'm going to use the SQL invoicing data, 

2551
02:50:00,000 --> 02:50:04,000
base, now let's select everything from the 

2552
02:50:04,000 --> 02:50:08,000
invoices table and join it to the clients table. 

2553
02:50:08,000 --> 02:50:12,000
here I'm going to use the using statement to simplify 

2554
02:50:12,000 --> 02:50:16,000
my join. What column are we going to use for joining? The client id 

2555
02:50:16,000 --> 02:50:20,000
column. Let's execute this query up to this point. 

2556
02:50:20,000 --> 02:50:24,000
Alright, so first we see client id column 

2557
02:50:24,000 --> 02:50:28,000
is used for joining these tables, after that we have the columns from 

2558
02:50:28,000 --> 02:50:32,000
the invoices table like invoice id number and so on. Followed by 

2559
02:50:32,000 --> 02:50:36,000
the columns from the clients table. Name 

2560
02:50:36,000 --> 02:50:40,000
address and so on. Obviously we don't want all these columns, we only want 

2561
02:50:40,000 --> 02:50:44,000
the columns from the invoices table but we should replace the client id 

2562
02:50:44,000 --> 02:50:48,000
column with he client name column. So let's have 

2563
02:50:48,000 --> 02:50:52,000
a quick look at the design of the invoices table 

2564
02:50:52,000 --> 02:50:56,000
here we have invoices id, number, 

2565
02:50:56,000 --> 02:51:00,000
client id, we want to replace this column with the client name. 

2566
02:51:00,000 --> 02:51:04,000
Back to our query, I'm going to pick, 

2567
02:51:04,000 --> 02:51:08,000
invoice id, number 

2568
02:51:08,000 --> 02:51:12,000
and then client.name, let's rename it to client 

2569
02:51:12,000 --> 02:51:16,000
what other columns do we have here? We have 

2570
02:51:16,000 --> 02:51:20,000
invoice total and payment total so let's add those as well, 

2571
02:51:20,000 --> 02:51:24,000
invoice total as well as payment total, 

2572
02:51:24,000 --> 02:51:28,000
we also have three columns, 

2573
02:51:28,000 --> 02:51:32,000
for dates, invoice date, due date, and payment date, 

2574
02:51:32,000 --> 02:51:36,000
so, let me close the navigator panel. Invoice 

2575
02:51:36,000 --> 02:51:40,000
date payment date and 

2576
02:51:40,000 --> 02:51:44,000
due date. Now technically because these columns only exist 

2577
02:51:44,000 --> 02:51:48,000
in the invoices table, we don't have to prefix them with the

2578
02:51:48,000 --> 02:51:52,000
table alias. So we can simplify the code like this, however, 

2579
02:51:52,000 --> 02:51:56,000
I personally prefer to prefix them, because that gives me a clear 

2580
02:51:56,000 --> 02:52:00,000
picture of how I'm joining these tables. It's just a personal preference 

2581
02:52:00,000 --> 02:52:04,000
another developer might disagree and that's fine, so whatever you prefer.

2582
02:52:04,000 --> 02:52:08,000
That's perfectly fine, let's execute the query and make sure 

2583
02:52:08,000 --> 02:52:12,000
we get the right result, so we have the invoice 

2584
02:52:12,000 --> 02:52:16,000
ID  number client beautiful, followed by these other 

2585
02:52:16,000 --> 02:52:20,000
columns, now I want to filter the result, and return 

2586
02:52:20,000 --> 02:52:24,000
only the invoices that do have a payment. So we can either 

2587
02:52:24,000 --> 02:52:28,000
return records that have a payment date, or the records that have 

2588
02:52:28,000 --> 02:52:32,000
a payment total of greater then 0. Both are perfectly 

2589
02:52:32,000 --> 02:52:36,000
fine, so back to our query, 

2590
02:52:36,000 --> 02:52:40,000
down at the bottom, let's add the where clause, where payment 

2591
02:52:40,000 --> 02:52:44,000
date is not null. That's better. 

2592
02:52:44,000 --> 02:52:48,000
Let's execute the query one more time, now we get only these 

2593
02:52:48,000 --> 02:52:52,000
handful of invoices, beautiful, finally let's use our 

2594
02:52:52,000 --> 02:52:56,000
query, as a subquery in a create table as

2595
02:52:56,000 --> 02:53:00,000
statement. So right before 

2596
02:53:00,000 --> 02:53:04,000
select we type create table, invoices, 

2597
02:53:04,000 --> 02:53:08,000
archive, as there you go, let's execute 

2598
02:53:08,000 --> 02:53:12,000
the query beautiful, now back to the navigator panel, 

2599
02:53:12,000 --> 02:53:16,000
let's refresh the view, so here's our new table, 

2600
02:53:16,000 --> 02:53:20,000
invoice and archive, let's look at the data, there you go. 

2601
02:53:20,000 --> 02:53:24,000
You only have the invoices page and here's the name of the

2602
02:53:24,000 --> 02:53:28,000
client for each invoice. Beautiful. Now just note that 

2603
02:53:28,000 --> 02:53:32,000
if you execute this query one more time, you're going to get an error because we already have a 

2604
02:53:32,000 --> 02:53:36,000
table called invoices archive. Later in the course I will show you how 

2605
02:53:36,000 --> 02:53:40,000
to draw tables, that's pretty easy, but for now you can just right click

2606
02:53:40,000 --> 02:53:44,000
and go to draw table and then confirm 

2607
02:53:44,000 --> 02:53:48,000
alright, and then you can run the query one more time. 

2608
02:53:48,000 --> 02:53:52,000


2609
02:53:52,000 --> 02:53:56,000
In this tutorial I'm going to show you how to update data in

2610
02:53:56,000 --> 02:54:00,000
SQL. So back to our invoices table, 

2611
02:54:00,000 --> 02:54:04,000
look at the first record here. The payment total for 

2612
02:54:04,000 --> 02:54:08,000
this record is 0, and obviously there is no payment date. 

2613
02:54:08,000 --> 02:54:12,000
Now let's imagine that there was a problem int he system that recorded this information. 

2614
02:54:12,000 --> 02:54:16,000
Let's say the client paid ten dollars for the invoice. So we should update this

2615
02:54:16,000 --> 02:54:20,000
record in this table. That is very easy, back ti our query editor, 

2616
02:54:20,000 --> 02:54:24,000
window, we use the update statement to update one or more records

2617
02:54:24,000 --> 02:54:28,000
in a table. What table? In this case invoices. 

2618
02:54:28,000 --> 02:54:32,000
Next we add a seth clause and this is where we specify a new value 

2619
02:54:32,000 --> 02:54:36,000
for one more or columns. In this case we want to update

2620
02:54:36,000 --> 02:54:40,000
payment total. Let's say to ten dollars. We should also update 

2621
02:54:40,000 --> 02:54:44,000
payment date. So here's a column to add more columns 

2622
02:54:44,000 --> 02:54:48,000
we set this to date value, let's say 

2623
02:54:48,000 --> 02:54:52,000
2019, March 1st, and then we type 

2624
02:54:52,000 --> 02:54:56,000
out a condition, with this condition we identify 

2625
02:54:56,000 --> 02:55:00,000
the record or the records that need to be updated. In this case we want to

2626
02:55:00,000 --> 02:55:04,000
update the invoice number 1. So, 

2627
02:55:04,000 --> 02:55:08,000
back to our query, we type out invoice id 

2628
02:55:08,000 --> 02:55:12,000
equal to 1. Let's execute this. Beautiful, 

2629
02:55:12,000 --> 02:55:16,000
Now back to our table, let's refresh the data by clicking on this icon. 

2630
02:55:16,000 --> 02:55:20,000
Alright, we can see that payment total is updated to ten. 

2631
02:55:20,000 --> 02:55:24,000
And we also have a payment date. Beautiful. Now lets say we actually 

2632
02:55:24,000 --> 02:55:28,000
updated the wrong record, maybe we should have updated invoice 

2633
02:55:28,000 --> 02:55:32,000
number 3, so we should update this table one more time, and restore the 

2634
02:55:32,000 --> 02:55:36,000
original values in this column, back to our query 

2635
02:55:36,000 --> 02:55:40,000
we can set the payment total to 0, and 

2636
02:55:40,000 --> 02:55:44,000
the payment date to null. So we can use the null

2637
02:55:44,000 --> 02:55:48,000
keyword to insert the null value in a column that accepts 

2638
02:55:48,000 --> 02:55:52,000
null values. Now back to the navigator panel, let's open the 

2639
02:55:52,000 --> 02:55:56,000
table in the design mode. We can see that the payment total column 

2640
02:55:56,000 --> 02:56:00,000
has a default value of 0, and the payment date column 

2641
02:56:00,000 --> 02:56:04,000
has the default value of null. So back in our query 

2642
02:56:04,000 --> 02:56:08,000
we can also set payment total tod default and MySQL 

2643
02:56:08,000 --> 02:56:12,000
will use the default value for this column, which is in this case 0. 

2644
02:56:12,000 --> 02:56:16,000
So, let's execute this statement one more time, beautiful. 

2645
02:56:16,000 --> 02:56:20,000
Now, back to the table, let's refresh the data, so payment total is set

2646
02:56:20,000 --> 02:56:24,000
to 0. And payment date is null. Beautiful. 

2647
02:56:24,000 --> 02:56:28,000
Now let's go ahead and update the third payment. Look at the

2648
02:56:28,000 --> 02:56:32,000
invoice total. That is $147. For this example let's 

2649
02:56:32,000 --> 02:56:36,000
imagine that the client made 50% of the total 

2650
02:56:36,000 --> 02:56:40,000
amount on the due date. So, back to our query 

2651
02:56:40,000 --> 02:56:44,000
editor window, instead of using a literal value window here like $70

2652
02:56:44,000 --> 02:56:48,000
we can write an expression, we want to calculate 50%

2653
02:56:48,000 --> 02:56:52,000
of invoice total. So invoice total, 

2654
02:56:52,000 --> 02:56:56,000
x 0.5. Now let me break this code into multiple 

2655
02:56:56,000 --> 02:57:00,000
lines so we can see clearly, now we should 

2656
02:57:00,000 --> 02:57:04,000
set the payment date, as I told you this client made the payment 

2657
02:57:04,000 --> 02:57:08,000
on the due date, so we can set this to due date. 

2658
02:57:08,000 --> 02:57:12,000
Whatever value we have in this column will be used to set the payment date. 

2659
02:57:12,000 --> 02:57:16,000
Now obviously we need to update the invoice id, 

2660
02:57:16,000 --> 02:57:20,000
number 3, now back in the table, let's refresh the data. 

2661
02:57:20,000 --> 02:57:24,000
Alright look, payment total is updated, and it's set

2662
02:57:24,000 --> 02:57:28,000
to almost 50% of he invoice total. However, 

2663
02:57:28,000 --> 02:57:32,000
this number is truncated so we don't have the digits after the decimal point. 

2664
02:57:32,000 --> 02:57:36,000
Don't worry about it for now, we'll come back to this when we talk about data points 

2665
02:57:36,000 --> 02:57:40,000
later in the course. Also we can see that payment date is set 

2666
02:57:40,000 --> 02:57:44,000
to the same value we have in the due date column. 

2667
02:57:44,000 --> 02:57:48,000


2668
02:57:48,000 --> 02:57:52,000
In the last tutorial we learned how to update a single record using the updates

2669
02:57:52,000 --> 02:57:56,000
statement. Now if you want to update multiple records, the syntax is 

2670
02:57:56,000 --> 02:58:00,000
exactly the same, but the condition you type out here, has to be more general. 

2671
02:58:00,000 --> 02:58:04,000
For example, back to the invoices table, you can see that we have multiple 

2672
02:58:04,000 --> 02:58:08,000
invoices for client number 3. You can write a statement 

2673
02:58:08,000 --> 02:58:12,000
to update all the invoices for this client. So back to our

2674
02:58:12,000 --> 02:58:16,000
query editor window, we change our condition to, 

2675
02:58:16,000 --> 02:58:20,000
where client id equals 3. However, if 

2676
02:58:20,000 --> 02:58:24,000
you execute this statement with MySQL workbench which is the software we've been using 

2677
02:58:24,000 --> 02:58:28,000
in this course, you're going to get an error, because by default, MySQL workbench 

2678
02:58:28,000 --> 02:58:32,000
runs in the safe update mode. So it allows you to update only 

2679
02:58:32,000 --> 02:58:36,000
a single record. You're not going to have this problem if you use another client for 

2680
02:58:36,000 --> 02:58:40,000
MySQL or if you write this statement in your application code 

2681
02:58:40,000 --> 02:58:44,000
this is only specific for MySQL workbench. Now

2682
02:58:44,000 --> 02:58:48,000
let me show you how to get around this. On the top we go to

2683
02:58:48,000 --> 02:58:52,000
MySQl workbench menu and then preface this. 

2684
02:58:52,000 --> 02:58:56,000
On this dial up box, on the left side, click on SQL editor 

2685
02:58:56,000 --> 02:59:00,000
and then down on the bottom, 

2686
02:59:00,000 --> 02:59:04,000
untick this checkbox, save updates, so this 

2687
02:59:04,000 --> 02:59:08,000
prevents you from accidentally updating or deleting a bunch of records in a table, 

2688
02:59:08,000 --> 02:59:12,000
so let's goa head with this, now we need to 

2689
02:59:12,000 --> 02:59:16,000
reconnect to this instance of MySQL. So, let's copy 

2690
02:59:16,000 --> 02:59:20,000
all the code here, and close this local instance 

2691
02:59:20,000 --> 02:59:24,000
window. Alright? Now, on the home page, double click this

2692
02:59:24,000 --> 02:59:28,000
connection to reconnect, there you go, and then paste 

2693
02:59:28,000 --> 02:59:32,000
all that Sql code. Now let's 

2694
02:59:32,000 --> 02:59:36,000
execute this, beautiful, all the invoices for client number 3 are updated. 

2695
02:59:36,000 --> 02:59:40,000
Here we can also use the in operator, let's say 

2696
02:59:40,000 --> 02:59:44,000
we want to update all the invoices for clients number 3 and number 4. 

2697
02:59:44,000 --> 02:59:48,000
So all the operators you learned to use in the where clause also 

2698
02:59:48,000 --> 02:59:52,000
apply here. Now technically this where clause is optional, so if you want 

2699
02:59:52,000 --> 02:59:56,000
to update all the records in a table, you simply leave it out. 

2700
02:59:56,000 --> 03:00:00,000


2701
03:00:00,000 --> 03:00:04,000
Alright here's your exercise for this tutorial. Back to our SQL store database, 

2702
03:00:04,000 --> 03:00:08,000
write a SQL statement to give any customers, 

2703
03:00:08,000 --> 03:00:12,000
born before 1990, 15 extra points. 

2704
03:00:12,000 --> 03:00:16,000


2705
03:00:16,000 --> 03:00:20,000
Alright first we're going to use SQL 

2706
03:00:20,000 --> 03:00:24,000
store, then, write an update statement. To update the customers table, 

2707
03:00:24,000 --> 03:00:28,000
set the points to point 

2708
03:00:28,000 --> 03:00:32,000
plus 15, so here we're using the expression to update 

2709
03:00:32,000 --> 03:00:36,000
the points column, for anyone born before 

2710
03:00:36,000 --> 03:00:40,000
1990. So where birth date is less then 

2711
03:00:40,000 --> 03:00:44,000
1990, January 1st. 

2712
03:00:44,000 --> 03:00:48,000
Alright, let's execute this query, alright, now 

2713
03:00:48,000 --> 03:00:52,000
let's open up the customers table one more time, 

2714
03:00:52,000 --> 03:00:56,000
so anyone who was born before 1990 now has an extra 

2715
03:00:56,000 --> 03:01:00,000
50 points. 

2716
03:01:00,000 --> 03:01:04,000
In this tutorial we're going to learn how to 

2717
03:01:04,000 --> 03:01:08,000
use subqueries in an update statement, it's extemely powerful, 

2718
03:01:08,000 --> 03:01:12,000
so we're going to continue with the example from the last tutorial, but we're going to

2719
03:01:12,000 --> 03:01:16,000
make it more interesting. Here we're updating all the invoices for 

2720
03:01:16,000 --> 03:01:20,000
client number 3, but what if we don't have the id of the client? We only have the

2721
03:01:20,000 --> 03:01:24,000
name? For example, you might even have an application, and in that application

2722
03:01:24,000 --> 03:01:28,000
the user types in the name of the client, so first we should find the 

2723
03:01:28,000 --> 03:01:32,000
id for that client, and then use that id to update all the invoices. 

2724
03:01:32,000 --> 03:01:36,000
How do we do that? Well, let's have a quick look at our clients 

2725
03:01:36,000 --> 03:01:40,000
table, so here we have this client 

2726
03:01:40,000 --> 03:01:44,000
my words, let's say you have the name, you want to find the id. 

2727
03:01:44,000 --> 03:01:48,000
So back to our query window. After our update statement 

2728
03:01:48,000 --> 03:01:52,000
I'm going to write the select statement to select the client id column, 

2729
03:01:52,000 --> 03:01:56,000
from the clients table, where name equals 

2730
03:01:56,000 --> 03:02:00,000
my works. Now here we have 

2731
03:02:00,000 --> 03:02:04,000
a syntax error, because we didn't terminate the last 

2732
03:02:04,000 --> 03:02:08,000
don't worry about that, we're going to get back to that in a second. Let's just select these few lines and 

2733
03:02:08,000 --> 03:02:12,000
execute this query. The idea of this client is 

2734
03:02:12,000 --> 03:02:16,000
2. Beautiful. Now we can use this select statement as 

2735
03:02:16,000 --> 03:02:20,000
a subquery in a update statement. So as I told you before, 

2736
03:02:20,000 --> 03:02:24,000
a subquery is a select statement that is within another SQL 

2737
03:02:24,000 --> 03:02:28,000
statement. So, instead of hard coding 3 here, 

2738
03:02:28,000 --> 03:02:32,000
we're going to use this select statement as a subquery, but 

2739
03:02:32,000 --> 03:02:36,000
we need to put it in parenthesis, so MySQL will 

2740
03:02:36,000 --> 03:02:40,000
execute this query first, it will return the client ID and then

2741
03:02:40,000 --> 03:02:44,000
use it in this condition. So for clarity 

2742
03:02:44,000 --> 03:02:48,000
let's remove the line break and indent 

2743
03:02:48,000 --> 03:02:52,000
these few lines. So this is the end result. Now 

2744
03:02:52,000 --> 03:02:56,000
we execute this query, and this updated all the invoices for this client. 

2745
03:02:56,000 --> 03:03:00,000
Now, what if this query returns multiple clients? 

2746
03:03:00,000 --> 03:03:04,000
For example, back to the clients table, let's imagine you want to update 

2747
03:03:04,000 --> 03:03:08,000
the invoices for all clients located in New York or California. 

2748
03:03:08,000 --> 03:03:12,000
So, we need to update our subquery, 

2749
03:03:12,000 --> 03:03:16,000
like this, where state 

2750
03:03:16,000 --> 03:03:20,000
in California, and 

2751
03:03:20,000 --> 03:03:24,000
New York. Now before executing the entire statement, 

2752
03:03:24,000 --> 03:03:28,000
let's just select our subquery and execute it to see what we get. 

2753
03:03:28,000 --> 03:03:32,000
So we get two client ID's, one and 

2754
03:03:32,000 --> 03:03:36,000
three, beautiful, now because this query, this subquery 

2755
03:03:36,000 --> 03:03:40,000
returns mutliple records, we cannot use an equal sign 

2756
03:03:40,000 --> 03:03:44,000
here anymore, so we need to replace this with an in operator. 

2757
03:03:44,000 --> 03:03:48,000
And now this statement updates the invoices for all the clients 

2758
03:03:48,000 --> 03:03:52,000
located in these two statements. Let's execute it, 

2759
03:03:52,000 --> 03:03:56,000
beautiful, everything worked. So as a best practice, before executing your 

2760
03:03:56,000 --> 03:04:00,000
update statement, run your query to see what records you're going to update. So you don't 

2761
03:04:00,000 --> 03:04:04,000
accidentally update the records that shouldn't be updated. Now here we 

2762
03:04:04,000 --> 03:04:08,000
have a subquery but even if we didn't have a subquery, you could still

2763
03:04:08,000 --> 03:04:12,000
query the records that we're going to update. Let me show you. So let's imagine 

2764
03:04:12,000 --> 03:04:16,000
we're going to update all the invoices where payment 

2765
03:04:16,000 --> 03:04:20,000
date is null. Before executing this entire update 

2766
03:04:20,000 --> 03:04:24,000
statement, I would run a query like this. Select, start 

2767
03:04:24,000 --> 03:04:28,000
I would start from invoices where payment date is null. 

2768
03:04:28,000 --> 03:04:32,000
Now let's execute this query, 

2769
03:04:32,000 --> 03:04:36,000
these are the two records that don't have payment date, so once we're confident that

2770
03:04:36,000 --> 03:04:40,000
we're updating the right records, then, we come back here, 

2771
03:04:40,000 --> 03:04:44,000
and get rid of this select statement, and just attach the where clause 

2772
03:04:44,000 --> 03:04:48,000
to our update statement. 

2773
03:04:48,000 --> 03:04:52,000
Alright, here's your 

2774
03:04:52,000 --> 03:04:56,000
exercise for this tutorial, back to our SQL store database, look at the 

2775
03:04:56,000 --> 03:05:00,000
orders table, as you can see, several orders don't have a 

2776
03:05:00,000 --> 03:05:04,000
comment, I want you to write a SQL statement to update the comments or orders

2777
03:05:04,000 --> 03:05:08,000
for customers who have more then 3000 points. 

2778
03:05:08,000 --> 03:05:12,000
So customers who have more then 3000 points, regard

2779
03:05:12,000 --> 03:05:16,000
them as gold customers. Find their orders, if they have placed an order

2780
03:05:16,000 --> 03:05:20,000
update the comments column and set it to gold customer. 

2781
03:05:20,000 --> 03:05:24,000
That's a really good exercise. 

2782
03:05:24,000 --> 03:05:28,000
Alright, first we need to find 

2783
03:05:28,000 --> 03:05:32,000
the gold customers, so select everything from the customers table, 

2784
03:05:32,000 --> 03:05:36,000
where points is greater then 3000. 

2785
03:05:36,000 --> 03:05:40,000
And by the way, because current database is SQL invoice 

2786
03:05:40,000 --> 03:05:44,000
we either have to type out a use statement on the top, or 

2787
03:05:44,000 --> 03:05:48,000
double click this database before executing this query. So, 

2788
03:05:48,000 --> 03:05:52,000
there you go. We have three gold customers 

2789
03:05:52,000 --> 03:05:56,000
now we need to get the ID of these customers to use them in an update 

2790
03:05:56,000 --> 03:06:00,000
statement. So, we only select customers 

2791
03:06:00,000 --> 03:06:04,000
Id here and then select this statement as a subquery 

2792
03:06:04,000 --> 03:06:08,000
in an update statement. So, 

2793
03:06:08,000 --> 03:06:12,000
update, orders, set comments to 

2794
03:06:12,000 --> 03:06:16,000
gold customer, where 

2795
03:06:16,000 --> 03:06:20,000
customer id because we're dealing with multiple customer id's 

2796
03:06:20,000 --> 03:06:24,000
we need to use the in operator and then to use it, 

2797
03:06:24,000 --> 03:06:28,000
as a subquery, we need to enclose it in parenthesis. 

2798
03:06:28,000 --> 03:06:32,000
Let's indent the code, that's better, so here 

2799
03:06:32,000 --> 03:06:36,000
is the final solution. 

2800
03:06:36,000 --> 03:06:40,000


2801
03:06:40,000 --> 03:06:44,000
So you have learned how to insert and update data, in this lecture, we're going to finish this section 

2802
03:06:44,000 --> 03:06:48,000
by learning how to delete data. That is very easy. We use the delete 

2803
03:06:48,000 --> 03:06:52,000
from statement to delete records from a table. 

2804
03:06:52,000 --> 03:06:56,000
Let's say the invoices table. Now optionally we can add a search condition 

2805
03:06:56,000 --> 03:07:00,000
to identify the records we want to delete. If you don't write

2806
03:07:00,000 --> 03:07:04,000
this where clause with this statement, we delete all the records in this table. 

2807
03:07:04,000 --> 03:07:08,000
And obviously, that's very dangerous, so be very careful when executing this

2808
03:07:08,000 --> 03:07:12,000
statement. Now here let's say we want to delete the invoice 

2809
03:07:12,000 --> 03:07:16,000
with the id 1, so where invoice id goes to 1. 

2810
03:07:16,000 --> 03:07:20,000
Now here we can also use subqueries, let's say we want to delete all the invoices for 

2811
03:07:20,000 --> 03:07:24,000
the client called my works. First let's 

2812
03:07:24,000 --> 03:07:28,000
find this client, so select everything from the client's table 

2813
03:07:28,000 --> 03:07:32,000
where name equals to my works. 

2814
03:07:32,000 --> 03:07:36,000
Let's execute the second query, so

2815
03:07:36,000 --> 03:07:40,000
here's our client,  now we can get this client 

2816
03:07:40,000 --> 03:07:44,000
id and use it in our search condition. So where 

2817
03:07:44,000 --> 03:07:48,000
client id equals 2, this is where we add

2818
03:07:48,000 --> 03:07:52,000
our subquery, there you go, just like before, 

2819
03:07:52,000 --> 03:07:56,000
beautiful. So this is how we can delete data, 

2820
03:07:56,000 --> 03:08:00,000
in SQL. 

2821
03:08:00,000 --> 03:08:04,000


2822
03:08:04,000 --> 03:08:08,000
Alright, we're done with this section, but before going to the next section, I want you to

2823
03:08:08,000 --> 03:08:12,000
restore all these databases to their original state. Because in this section we 

2824
03:08:12,000 --> 03:08:16,000
added some data, we updated some data, we deleted some records, 

2825
03:08:16,000 --> 03:08:20,000
so if you don't restore these databases you may see different results going forward. 

2826
03:08:20,000 --> 03:08:24,000
So, restoring these databases is pretty easy. Here in My

2827
03:08:24,000 --> 03:08:28,000
SQL workbench, on the top go to the file menu 

2828
03:08:28,000 --> 03:08:32,000
and open SQL script. Then navigate to the directory 

2829
03:08:32,000 --> 03:08:36,000
where you stored the SQL scripts for this course, in case you lost 

2830
03:08:36,000 --> 03:08:40,000
that directory, go back to the first section, you have a lecture for downloading the

2831
03:08:40,000 --> 03:08:44,000
supplementary materials. So in this directory open 

2832
03:08:44,000 --> 03:08:48,000
create databases.SQL. 

2833
03:08:48,000 --> 03:08:52,000
Now execute this script to recreate all of our databases. 

2834
03:08:52,000 --> 03:08:56,000
Alright, beautiful, now let's open up the navigator panel, you can see the 

2835
03:08:56,000 --> 03:09:00,000
databases disappear from here, simply click on this refresh icon. 

2836
03:09:00,000 --> 03:09:04,000
Beautiful. Alright, we're done with this section, I will see you in the next 

2837
03:09:04,000 --> 03:09:08,000
section. Hey guys, Mosh here, 

2838
03:09:08,000 --> 03:09:12,000
in case you haven't seen my website yet, head over to codewithmosh

2839
03:09:12,000 --> 03:09:16,000
.com. This is my coding school where you can find plenty of courses 

2840
03:09:16,000 --> 03:09:20,000
on web and mobile application development. In fact recently I 

2841
03:09:20,000 --> 03:09:24,000
published a complete SQL course that is about 10 hours long, 

2842
03:09:24,000 --> 03:09:28,000
and it teaches you everything you need to know from the basic to advanced topics

2843
03:09:28,000 --> 03:09:32,000
such as database design, security, writing complex queries, 

2844
03:09:32,000 --> 03:09:36,000
transactions, events and much, much more. These are the topics 

2845
03:09:36,000 --> 03:09:40,000
that every software engineer must master. This Youtube 

2846
03:09:40,000 --> 03:09:44,000
course you've been watching is the first three hours of my complete SQL

2847
03:09:44,000 --> 03:09:48,000
course that is about 10 hours long. So if you want to master SQL 

2848
03:09:48,000 --> 03:09:52,000
and get job ready, I highly encourage you to get involved in my complete 

2849
03:09:52,000 --> 03:09:56,000
SQL course. You can watch it anytime, anywhere, as many times as you

2850
03:09:56,000 --> 03:10:00,000
want, you can watch it online or download the videos. The course comes with 

2851
03:10:00,000 --> 03:10:04,000
a 30 day money back guarantee and a certificate of completion 

2852
03:10:04,000 --> 03:10:08,000
that you can add to your resume. The price for this course is $149

2853
03:10:08,000 --> 03:10:12,000
but the first 200 students can get it for just

2854
03:10:12,000 --> 03:10:16,000
over $100. So if you're interseted, the link is below this video. 

2855
03:10:16,000 --> 00:00:00,000


